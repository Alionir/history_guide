2025-05-25 20:36:57,851 - core.database - INFO - Database connection pool initialized successfully
2025-05-25 20:37:00,510 - __main__ - INFO - Login cancelled by user
2025-05-25 20:37:00,511 - core.database - INFO - Database connection pool closed
2025-05-25 20:53:19,823 - core.database - INFO - Database connection pool initialized successfully
2025-05-25 20:53:29,092 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99da1be0>
2025-05-25 20:53:29,370 - core.auth - INFO - User magcurie authenticated successfully
2025-05-25 20:53:30,386 - __main__ - INFO - User logged in successfully: magcurie
2025-05-25 20:53:30,612 - ui.main_window - INFO - Main window opened for user: magcurie
2025-05-25 20:53:30,708 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99da1be0>
2025-05-25 20:53:30,920 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99da1be0>
2025-05-25 20:53:31,118 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99e20a50>
2025-05-25 20:53:31,153 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99da1be0>
2025-05-25 20:53:31,326 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99e20a50>
2025-05-25 20:53:31,364 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99da1be0>
2025-05-25 20:53:31,530 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99e20a50>
2025-05-25 20:53:31,537 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99e20cd0>
2025-05-25 20:53:31,586 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'PERSONS_LIST_VIEWED', None, None, 'Просмотр списка персон', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,655 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,656 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,657 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,735 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'COUNTRIES_LIST_VIEWED', None, None, 'Просмотр списка стран', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,741 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'EVENTS_LIST_VIEWED', None, None, 'Просмотр списка событий', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,795 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'DOCUMENTS_LIST_VIEWED', None, None, 'Просмотр списка документов', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,803 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,804 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,804 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,811 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,811 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,811 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,904 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,905 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,905 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,975 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'SOURCES_LIST_VIEWED', None, None, 'Просмотр списка источников', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:31,975 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99e20cd0>
2025-05-25 20:53:32,045 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:32,045 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:32,046 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:53:32,046 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99da1be0>
2025-05-25 20:53:32,184 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99dd63f0>
2025-05-25 20:53:32,258 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99e20cd0>
2025-05-25 20:53:32,391 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99e20a50>
2025-05-25 20:53:32,465 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99da1be0>
2025-05-25 20:53:32,598 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99dd63f0>
2025-05-25 20:53:32,673 - core.database - ERROR - Error executing function sp_get_user_activity_stats with params (datetime.datetime(2025, 5, 18, 20, 53, 32, 534970), datetime.datetime(2025, 5, 25, 20, 53, 32, 534983)): column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:32,741 - core.database - ERROR - Database error: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:32,741 - data_access.base_repository - ERROR - Error executing function sp_get_user_activity_stats: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:32,742 - ui.components.welcome_widget - ERROR - Error loading stats: Database operation failed: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:32,804 - core.database - ERROR - Error executing function sp_get_user_activity_stats with params (datetime.datetime(2025, 5, 18, 20, 53, 32, 667454), datetime.datetime(2025, 5, 25, 20, 53, 32, 667468)): column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:32,872 - core.database - ERROR - Database error: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:32,872 - data_access.base_repository - ERROR - Error executing function sp_get_user_activity_stats: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:32,873 - ui.components.welcome_widget - ERROR - Error loading stats: Database operation failed: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:37,721 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99da1be0>
2025-05-25 20:53:37,929 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99dd63f0>
2025-05-25 20:53:38,134 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99e20cd0>
2025-05-25 20:53:38,338 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99e20a50>
2025-05-25 20:53:38,545 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x20e99da1be0>
2025-05-25 20:53:38,752 - core.database - ERROR - Error executing function sp_get_user_activity_stats with params (datetime.datetime(2025, 5, 18, 20, 53, 38, 614369), datetime.datetime(2025, 5, 25, 20, 53, 38, 614380)): column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:38,821 - core.database - ERROR - Database error: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:38,821 - data_access.base_repository - ERROR - Error executing function sp_get_user_activity_stats: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:38,822 - ui.components.welcome_widget - ERROR - Error loading stats: Database operation failed: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:53:53,545 - core.database - INFO - Database connection pool closed
2025-05-25 20:55:55,814 - core.database - INFO - Database connection pool initialized successfully
2025-05-25 20:56:00,697 - __main__ - INFO - Login cancelled by user
2025-05-25 20:56:00,698 - core.database - INFO - Database connection pool closed
2025-05-25 20:56:01,045 - core.auth - INFO - User magcurie authenticated successfully
2025-05-25 20:56:25,675 - core.database - INFO - Database connection pool initialized successfully
2025-05-25 20:56:33,509 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd2c46e0>
2025-05-25 20:56:33,798 - core.auth - INFO - User magcurie authenticated successfully
2025-05-25 20:56:34,811 - __main__ - INFO - User logged in successfully: magcurie
2025-05-25 20:56:35,038 - ui.main_window - INFO - Main window opened for user: magcurie
2025-05-25 20:56:35,108 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd2c46e0>
2025-05-25 20:56:35,330 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd2c46e0>
2025-05-25 20:56:35,539 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd330b90>
2025-05-25 20:56:35,552 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd2c46e0>
2025-05-25 20:56:35,744 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd330b90>
2025-05-25 20:56:35,773 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd2c46e0>
2025-05-25 20:56:35,946 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd330e10>
2025-05-25 20:56:35,948 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd330b90>
2025-05-25 20:56:36,001 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'PERSONS_LIST_VIEWED', None, None, 'Просмотр списка персон', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,075 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,076 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,077 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,146 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'COUNTRIES_LIST_VIEWED', None, None, 'Просмотр списка стран', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,151 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'EVENTS_LIST_VIEWED', None, None, 'Просмотр списка событий', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,214 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,214 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,214 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,219 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,219 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,220 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,224 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'DOCUMENTS_LIST_VIEWED', None, None, 'Просмотр списка документов', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,297 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,298 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,298 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,348 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'SOURCES_LIST_VIEWED', None, None, 'Просмотр списка источников', None, None, None, None): column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,359 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd330b90>
2025-05-25 20:56:36,400 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd2e6190>
2025-05-25 20:56:36,415 - core.database - ERROR - Database error: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,416 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,416 - services.base_service - ERROR - Failed to log action: Database operation failed: column "action_type" of relation "audit_logs" does not exist
LINE 2:         user_id, action_type, entity_type, entity_id, descri...
                         ^
QUERY:  INSERT INTO public.audit_logs (
        user_id, action_type, entity_type, entity_id, description,
        old_values, new_values, ip_address, user_agent, created_at
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )
CONTEXT:  PL/pgSQL function sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text) line 3 at SQL statement
2025-05-25 20:56:36,576 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd2c46e0>
2025-05-25 20:56:36,606 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd330e10>
2025-05-25 20:56:36,787 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd330b90>
2025-05-25 20:56:36,818 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd2e6190>
2025-05-25 20:56:37,002 - core.database - ERROR - Error executing function sp_get_user_activity_stats with params (datetime.datetime(2025, 5, 18, 20, 56, 36, 855260), datetime.datetime(2025, 5, 25, 20, 56, 36, 855275)): column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:56:37,024 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x193dd330e10>
2025-05-25 20:56:37,076 - core.database - ERROR - Database error: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:56:37,077 - data_access.base_repository - ERROR - Error executing function sp_get_user_activity_stats: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:56:37,077 - ui.components.welcome_widget - ERROR - Error loading stats: Database operation failed: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:56:37,226 - core.database - ERROR - Error executing function sp_get_user_activity_stats with params (datetime.datetime(2025, 5, 18, 20, 56, 37, 91038), datetime.datetime(2025, 5, 25, 20, 56, 37, 91048)): column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:56:37,294 - core.database - ERROR - Database error: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:56:37,295 - data_access.base_repository - ERROR - Error executing function sp_get_user_activity_stats: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-25 20:56:37,295 - ui.components.welcome_widget - ERROR - Error loading stats: Database operation failed: column al.action_type does not exist
LINE 1: SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTI...
               ^
QUERY:  SELECT al.action_type, COUNT(*) as action_count, COUNT(DISTINCT al.user_id) as unique_users
    FROM public.audit_logs al
    WHERE al.created_at BETWEEN p_start_date AND p_end_date
    GROUP BY al.action_type
    ORDER BY action_count DESC
CONTEXT:  PL/pgSQL function sp_get_user_activity_stats(timestamp without time zone,timestamp without time zone) line 3 at RETURN QUERY
2025-05-29 17:50:26,043 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 17:50:34,897 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x1eed6e3b770>
2025-05-29 17:54:15,044 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=ep-plain-sunset-a948pgxc-pooler.gwc.azure.neon.tech user=history_guide_owner database=history_guide) at 0x1eed6e3b770>
2025-05-29 17:58:30,698 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 17:58:40,456 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x16169ff78c0>
2025-05-29 17:58:54,251 - __main__ - INFO - Login cancelled by user
2025-05-29 17:58:54,252 - core.database - INFO - Database connection pool closed
2025-05-29 17:58:57,910 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:07:11,430 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:07:42,218 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x246927978c0>
2025-05-29 18:07:42,520 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x246927978c0>
2025-05-29 18:07:42,572 - core.database - ERROR - Error executing function sp_log_user_action with params (10, 'USER_REGISTERED', 'USER', 10, 'Зарегистрирован новый пользователь: eldar', None, None, None, None): значение NULL в столбце "action" отношения "audit_logs" нарушает ограничение NOT NULL
DETAIL:  Ошибочная строка содержит (91, 10, null, USER, 10, null, null, 2025-05-29 18:07:42.521123, USER_REGISTERED, null, null, Зарегистрирован новый пользовател..., null, null, 2025-05-29 18:07:42.521123).
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:07:42,572 - core.database - ERROR - Database error: значение NULL в столбце "action" отношения "audit_logs" нарушает ограничение NOT NULL
DETAIL:  Ошибочная строка содержит (91, 10, null, USER, 10, null, null, 2025-05-29 18:07:42.521123, USER_REGISTERED, null, null, Зарегистрирован новый пользовател..., null, null, 2025-05-29 18:07:42.521123).
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:07:42,573 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: значение NULL в столбце "action" отношения "audit_logs" нарушает ограничение NOT NULL
DETAIL:  Ошибочная строка содержит (91, 10, null, USER, 10, null, null, 2025-05-29 18:07:42.521123, USER_REGISTERED, null, null, Зарегистрирован новый пользовател..., null, null, 2025-05-29 18:07:42.521123).
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:07:42,573 - services.base_service - ERROR - Failed to log action: Database operation failed: значение NULL в столбце "action" отношения "audit_logs" нарушает ограничение NOT NULL
DETAIL:  Ошибочная строка содержит (91, 10, null, USER, 10, null, null, 2025-05-29 18:07:42.521123, USER_REGISTERED, null, null, Зарегистрирован новый пользовател..., null, null, 2025-05-29 18:07:42.521123).
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:08:43,121 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:08:53,759 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x13ea79578c0>
2025-05-29 18:08:53,809 - core.database - ERROR - Error executing function sp_log_user_action with params (0, 'LOGIN_FAILED', None, None, 'Неудачная попытка входа: eldar', None, None, None, None): INSERT или UPDATE в таблице "audit_logs" нарушает ограничение внешнего ключа "audit_logs_user_id_fkey"
DETAIL:  Ключ (user_id)=(0) отсутствует в таблице "users".
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:08:53,809 - core.database - ERROR - Database error: INSERT или UPDATE в таблице "audit_logs" нарушает ограничение внешнего ключа "audit_logs_user_id_fkey"
DETAIL:  Ключ (user_id)=(0) отсутствует в таблице "users".
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:08:53,810 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: INSERT или UPDATE в таблице "audit_logs" нарушает ограничение внешнего ключа "audit_logs_user_id_fkey"
DETAIL:  Ключ (user_id)=(0) отсутствует в таблице "users".
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:08:53,810 - services.base_service - ERROR - Failed to log action: Database operation failed: INSERT или UPDATE в таблице "audit_logs" нарушает ограничение внешнего ключа "audit_logs_user_id_fkey"
DETAIL:  Ключ (user_id)=(0) отсутствует в таблице "users".
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:09:01,936 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x13ea79578c0>
2025-05-29 18:09:01,937 - core.database - ERROR - Error executing function sp_log_user_action with params (0, 'LOGIN_FAILED', None, None, 'Неудачная попытка входа: eldar', None, None, None, None): INSERT или UPDATE в таблице "audit_logs" нарушает ограничение внешнего ключа "audit_logs_user_id_fkey"
DETAIL:  Ключ (user_id)=(0) отсутствует в таблице "users".
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:09:01,937 - core.database - ERROR - Database error: INSERT или UPDATE в таблице "audit_logs" нарушает ограничение внешнего ключа "audit_logs_user_id_fkey"
DETAIL:  Ключ (user_id)=(0) отсутствует в таблице "users".
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:09:01,938 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: INSERT или UPDATE в таблице "audit_logs" нарушает ограничение внешнего ключа "audit_logs_user_id_fkey"
DETAIL:  Ключ (user_id)=(0) отсутствует в таблице "users".
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:09:01,938 - services.base_service - ERROR - Failed to log action: Database operation failed: INSERT или UPDATE в таблице "audit_logs" нарушает ограничение внешнего ключа "audit_logs_user_id_fkey"
DETAIL:  Ключ (user_id)=(0) отсутствует в таблице "users".
CONTEXT:  SQL-оператор: "INSERT INTO public.audit_logs (
        user_id, action_type, table_name, record_id, description,
        old_values, new_values, ip_address, user_agent, timestamp
    )
    VALUES (
        p_user_id, p_action_type, p_entity_type, p_entity_id, p_description,
        p_old_values, p_new_values, p_ip_address, p_user_agent, CURRENT_TIMESTAMP
    )"
функция PL/pgSQL sp_log_user_action(integer,character varying,character varying,integer,text,jsonb,jsonb,inet,text), строка 3, оператор SQL-оператор
2025-05-29 18:10:03,776 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x13ea79578c0>
2025-05-29 18:10:17,004 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x13ea79578c0>
2025-05-29 18:13:05,473 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:13:11,877 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:12,089 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:12,929 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 18:13:13,059 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,061 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,082 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,083 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,154 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,155 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,161 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,162 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,167 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,168 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,169 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:13,170 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:34,101 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:34,102 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:45,624 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:53,726 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:53,743 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:53,744 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:55,101 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:13:55,103 - psycopg.pool - WARNING - rolling back returned connection: <psycopg.Connection [INTRANS] (host=localhost user=postgres database=history_guide) at 0x17f11ca38c0>
2025-05-29 18:17:35,523 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x00000267D4EFEA50>>: discarded
2025-05-29 18:17:35,529 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x00000267D4EFEA50>>: discarded
2025-05-29 18:17:35,530 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x00000267D4EFEA50>>: discarded
2025-05-29 18:17:36,620 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x00000267D4EFEA50>>: discarded
2025-05-29 18:17:36,621 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x00000267D4EFEA50>>: discarded
2025-05-29 18:17:36,719 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x00000267D4EFEA50>>: discarded
2025-05-29 18:17:38,734 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x00000267D4EFEA50>>: discarded
2025-05-29 18:17:38,736 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x00000267D4EFEA50>>: discarded
2025-05-29 18:17:38,812 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x00000267D4EFEA50>>: discarded
2025-05-29 18:17:43,277 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x0000027589032A50>>: discarded
2025-05-29 18:17:43,278 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x0000027589032A50>>: discarded
2025-05-29 18:17:43,278 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x0000027589032A50>>: discarded
2025-05-29 18:17:45,112 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:45,113 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:45,113 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:46,065 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:46,131 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:46,188 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:47,917 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:48,117 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:48,271 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:51,576 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:52,026 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:52,508 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:58,844 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:17:59,899 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:18:00,813 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001B437202A50>>: discarded
2025-05-29 18:18:13,370 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:13,370 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:13,370 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:14,389 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:14,421 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:14,436 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:16,375 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:16,469 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:16,630 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:20,298 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:20,539 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:20,854 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:28,077 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:28,624 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:29,149 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:43,315 - core.database - ERROR - Database error: couldn't get a connection after 30.00 sec
2025-05-29 18:18:43,316 - core.database - ERROR - Failed to initialize database pool (attempt 1/3): couldn't get a connection after 30.00 sec
2025-05-29 18:18:43,591 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:44,718 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:45,372 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:45,379 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:45,379 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:45,534 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:46,413 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:46,430 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:46,472 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:48,401 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:48,450 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:48,484 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:52,324 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:52,374 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:52,440 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:18:59,897 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:00,115 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:00,359 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:14,545 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:14,993 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:15,324 - core.database - ERROR - Database error: couldn't get a connection after 30.00 sec
2025-05-29 18:19:15,324 - core.database - ERROR - Failed to initialize database pool (attempt 2/3): couldn't get a connection after 30.00 sec
2025-05-29 18:19:15,568 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:16,153 - psycopg.pool - WARNING - error connecting in 'pool-2': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:16,863 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:18,194 - psycopg.pool - WARNING - error connecting in 'pool-1': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:19,385 - psycopg.pool - WARNING - error connecting in 'pool-3': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:19,390 - psycopg.pool - WARNING - error connecting in 'pool-3': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:19,478 - psycopg.pool - WARNING - error connecting in 'pool-3': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:20,530 - psycopg.pool - WARNING - error connecting in 'pool-3': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:20,532 - psycopg.pool - WARNING - error connecting in 'pool-3': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:20,585 - psycopg.pool - WARNING - error connecting in 'pool-3': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:22,746 - psycopg.pool - WARNING - error connecting in 'pool-3': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:22,775 - psycopg.pool - WARNING - error connecting in 'pool-3': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:22,790 - psycopg.pool - WARNING - error connecting in 'pool-3': connection left in status INTRANS by configure function <bound method DatabaseConnection._configure_connection of <core.database.DatabaseConnection object at 0x000001AB449C2A50>>: discarded
2025-05-29 18:19:41,668 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:19:51,927 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 18:21:55,301 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:22:02,466 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 18:22:30,222 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:22:37,320 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 18:24:28,510 - core.database - ERROR - Error executing function sp_create_country_direct with params (3, 'СССР', 'Москва', PyQt6.QtCore.QDate(1922, 12, 30), PyQt6.QtCore.QDate(1991, 12, 26), 'Союз Советских Социалистических Республик (СССР), существовавший с 1922 по 1991 год, был крупнейшим в мире, многонациональным государством. Его территория охватывала обширные просторы Европы и Азии, объединяя народы с различной историей, культурой и языками. Союз имел форму правления федеративной республики, при которой властные полномочия разделяются между общегосударственными и республиканскими органами, и включал в себя 15 союзных республик. Однако не все они вошли в состав СССР одновременно'): cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 18:24:28,511 - core.database - ERROR - Database error: cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 18:24:28,511 - data_access.base_repository - ERROR - Error executing function sp_create_country_direct: cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 18:24:33,657 - core.database - ERROR - Error executing function sp_create_country_direct with params (3, 'СССР', 'Москва', None, None, 'Союз Советских Социалистических Республик (СССР), существовавший с 1922 по 1991 год, был крупнейшим в мире, многонациональным государством. Его территория охватывала обширные просторы Европы и Азии, объединяя народы с различной историей, культурой и языками. Союз имел форму правления федеративной республики, при которой властные полномочия разделяются между общегосударственными и республиканскими органами, и включал в себя 15 союзных республик. Однако не все они вошли в состав СССР одновременно'): неоднозначная ссылка на столбец "country_id"
LINE 1: SELECT country_id                             FROM public.co...
               ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  SELECT country_id                             FROM public.countries
    WHERE LOWER(name) = LOWER(TRIM(p_name))
CONTEXT:  функция PL/pgSQL sp_create_country_direct(integer,character varying,character varying,date,date,text), строка 24, оператор SQL-оператор
2025-05-29 18:24:33,657 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "country_id"
LINE 1: SELECT country_id                             FROM public.co...
               ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  SELECT country_id                             FROM public.countries
    WHERE LOWER(name) = LOWER(TRIM(p_name))
CONTEXT:  функция PL/pgSQL sp_create_country_direct(integer,character varying,character varying,date,date,text), строка 24, оператор SQL-оператор
2025-05-29 18:24:33,658 - data_access.base_repository - ERROR - Error executing function sp_create_country_direct: неоднозначная ссылка на столбец "country_id"
LINE 1: SELECT country_id                             FROM public.co...
               ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  SELECT country_id                             FROM public.countries
    WHERE LOWER(name) = LOWER(TRIM(p_name))
CONTEXT:  функция PL/pgSQL sp_create_country_direct(integer,character varying,character varying,date,date,text), строка 24, оператор SQL-оператор
2025-05-29 18:25:20,960 - core.database - ERROR - Error executing function sp_create_country_direct with params (3, 'СССР', 'Москва', None, None, 'Союз Советских Социалистических Республик (СССР), существовавший с 1922 по 1991 год, был крупнейшим в мире, многонациональным государством. Его территория охватывала обширные просторы Европы и Азии, объединяя народы с различной историей, культурой и языками. Союз имел форму правления федеративной республики, при которой властные полномочия разделяются между общегосударственными и республиканскими органами, и включал в себя 15 союзных республик. Однако не все они вошли в состав СССР одновременно'): неоднозначная ссылка на столбец "country_id"
LINE 1: SELECT country_id                             FROM public.co...
               ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  SELECT country_id                             FROM public.countries
    WHERE LOWER(name) = LOWER(TRIM(p_name))
CONTEXT:  функция PL/pgSQL sp_create_country_direct(integer,character varying,character varying,date,date,text), строка 24, оператор SQL-оператор
2025-05-29 18:25:20,961 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "country_id"
LINE 1: SELECT country_id                             FROM public.co...
               ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  SELECT country_id                             FROM public.countries
    WHERE LOWER(name) = LOWER(TRIM(p_name))
CONTEXT:  функция PL/pgSQL sp_create_country_direct(integer,character varying,character varying,date,date,text), строка 24, оператор SQL-оператор
2025-05-29 18:25:20,961 - data_access.base_repository - ERROR - Error executing function sp_create_country_direct: неоднозначная ссылка на столбец "country_id"
LINE 1: SELECT country_id                             FROM public.co...
               ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  SELECT country_id                             FROM public.countries
    WHERE LOWER(name) = LOWER(TRIM(p_name))
CONTEXT:  функция PL/pgSQL sp_create_country_direct(integer,character varying,character varying,date,date,text), строка 24, оператор SQL-оператор
2025-05-29 18:27:59,425 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:28:08,358 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'LOGIN_SUCCESS', None, None, 'Успешный вход в систему', None, None, None, None): функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:08,359 - core.database - ERROR - Database error: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:08,359 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:08,360 - services.base_service - ERROR - Failed to log action: Database operation failed: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,216 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 18:28:09,239 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'PERSONS_LIST_VIEWED', None, None, 'Просмотр списка персон', None, None, None, None): функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,240 - core.database - ERROR - Database error: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,240 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,241 - services.base_service - ERROR - Failed to log action: Database operation failed: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,252 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'COUNTRIES_LIST_VIEWED', None, None, 'Просмотр списка стран', None, None, None, None): функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,253 - core.database - ERROR - Database error: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,253 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,253 - services.base_service - ERROR - Failed to log action: Database operation failed: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,264 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'EVENTS_LIST_VIEWED', None, None, 'Просмотр списка событий', None, None, None, None): функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,264 - core.database - ERROR - Database error: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,264 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,265 - services.base_service - ERROR - Failed to log action: Database operation failed: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,271 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'DOCUMENTS_LIST_VIEWED', None, None, 'Просмотр списка документов', None, None, None, None): функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,272 - core.database - ERROR - Database error: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,272 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,272 - services.base_service - ERROR - Failed to log action: Database operation failed: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,277 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'SOURCE_TYPES_VIEWED', None, None, 'Просмотр типов источников', None, None, None, None): функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,277 - core.database - ERROR - Database error: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,277 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,277 - services.base_service - ERROR - Failed to log action: Database operation failed: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,280 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'SOURCES_LIST_VIEWED', None, None, 'Просмотр списка источников', None, None, None, None): функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,281 - core.database - ERROR - Database error: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,281 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:09,281 - services.base_service - ERROR - Failed to log action: Database operation failed: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:16,739 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'PERSON_VIEWED', 'PERSON', 6, 'Просмотр персоны: Владими Ильич Ленин', None, None, None, None): функция sp_log_user_action(smallint, unknown, unknown, smallint, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:16,739 - core.database - ERROR - Database error: функция sp_log_user_action(smallint, unknown, unknown, smallint, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:16,739 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: функция sp_log_user_action(smallint, unknown, unknown, smallint, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:16,739 - services.base_service - ERROR - Failed to log action: Database operation failed: функция sp_log_user_action(smallint, unknown, unknown, smallint, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:18,881 - core.database - ERROR - Error executing function sp_log_user_action with params (3, 'COUNTRIES_LIST_VIEWED', None, None, 'Просмотр списка стран', None, None, None, None): функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:18,881 - core.database - ERROR - Database error: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:18,882 - data_access.base_repository - ERROR - Error executing function sp_log_user_action: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:18,882 - services.base_service - ERROR - Failed to log action: Database operation failed: функция sp_log_user_action(smallint, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown) не уникальна
LINE 1: SELECT * FROM sp_log_user_action($1, $2, $3, $4, $5, $6, $7,...
                      ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
2025-05-29 18:28:23,205 - core.database - ERROR - Error executing function sp_update_person_direct with params (3, 6, 'Владимир', 'Ильич', 'Ленин', None, None, '1', None): функция sp_log_user_action(integer, unknown, unknown, integer, text) не уникальна
LINE 1: SELECT sp_log_user_action(
               ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
QUERY:  SELECT sp_log_user_action(
        p_moderator_id,
        'PERSON_UPDATED',
        'PERSON',
        p_person_id,
        format('Обновлена персона: %s -> %s %s', v_old_name, p_name, COALESCE(p_surname, ''))::text
    )
CONTEXT:  функция PL/pgSQL sp_update_person_direct(integer,integer,character varying,character varying,character varying,date,date,text,integer), строка 54, оператор PERFORM
2025-05-29 18:28:23,206 - core.database - ERROR - Database error: функция sp_log_user_action(integer, unknown, unknown, integer, text) не уникальна
LINE 1: SELECT sp_log_user_action(
               ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
QUERY:  SELECT sp_log_user_action(
        p_moderator_id,
        'PERSON_UPDATED',
        'PERSON',
        p_person_id,
        format('Обновлена персона: %s -> %s %s', v_old_name, p_name, COALESCE(p_surname, ''))::text
    )
CONTEXT:  функция PL/pgSQL sp_update_person_direct(integer,integer,character varying,character varying,character varying,date,date,text,integer), строка 54, оператор PERFORM
2025-05-29 18:28:23,206 - data_access.base_repository - ERROR - Error executing function sp_update_person_direct: функция sp_log_user_action(integer, unknown, unknown, integer, text) не уникальна
LINE 1: SELECT sp_log_user_action(
               ^
HINT:  Не удалось выбрать лучшую кандидатуру функции. Возможно, вам следует добавить явные приведения типов.
QUERY:  SELECT sp_log_user_action(
        p_moderator_id,
        'PERSON_UPDATED',
        'PERSON',
        p_person_id,
        format('Обновлена персона: %s -> %s %s', v_old_name, p_name, COALESCE(p_surname, ''))::text
    )
CONTEXT:  функция PL/pgSQL sp_update_person_direct(integer,integer,character varying,character varying,character varying,date,date,text,integer), строка 54, оператор PERFORM
2025-05-29 18:30:53,145 - core.database - ERROR - Error executing function sp_update_person_direct with params (3, 6, 'Владимир', 'Ильич', 'Ленин', PyQt6.QtCore.QDate(1870, 4, 22), PyQt6.QtCore.QDate(1924, 1, 21), '1', None): cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 18:30:53,146 - core.database - ERROR - Database error: cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 18:30:53,146 - data_access.base_repository - ERROR - Error executing function sp_update_person_direct: cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 18:45:45,753 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:45:52,452 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 18:51:21,834 - core.database - ERROR - Error executing function sp_search_persons_fulltext with params ('Ленин', 0, 20): structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 11.
CONTEXT:  SQL-оператор: "SELECT 
        p.person_id,
        p.name,
        p.surname,
        p.patronymic,
        TRIM(CONCAT(p.name, ' ', COALESCE(p.surname, ''), ' ', COALESCE(p.patronymic, ''))) as full_name,
        p.date_of_birth,
        p.date_of_death,
        CASE 
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - ', EXTRACT(YEAR FROM p.date_of_death))
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - н.в.')
            ELSE '? - ?'
        END as life_years,
        p.biography,
        c.name as country_name,
        (
            CASE WHEN p.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p.surname ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN p.patronymic ILIKE '%' || p_search_text || '%' THEN 1.5 ELSE 0.0 END +
            CASE WHEN p.biography ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.persons p
    LEFT JOIN public.countries c ON p.country_id = c.country_id
    WHERE 
        p.name ILIKE '%' || p_search_text || '%' OR 
        p.surname ILIKE '%' || p_search_text || '%' OR
        p.patronymic ILIKE '%' || p_search_text || '%' OR
        p.biography ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, p.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_persons_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 18:51:21,835 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 11.
CONTEXT:  SQL-оператор: "SELECT 
        p.person_id,
        p.name,
        p.surname,
        p.patronymic,
        TRIM(CONCAT(p.name, ' ', COALESCE(p.surname, ''), ' ', COALESCE(p.patronymic, ''))) as full_name,
        p.date_of_birth,
        p.date_of_death,
        CASE 
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - ', EXTRACT(YEAR FROM p.date_of_death))
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - н.в.')
            ELSE '? - ?'
        END as life_years,
        p.biography,
        c.name as country_name,
        (
            CASE WHEN p.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p.surname ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN p.patronymic ILIKE '%' || p_search_text || '%' THEN 1.5 ELSE 0.0 END +
            CASE WHEN p.biography ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.persons p
    LEFT JOIN public.countries c ON p.country_id = c.country_id
    WHERE 
        p.name ILIKE '%' || p_search_text || '%' OR 
        p.surname ILIKE '%' || p_search_text || '%' OR
        p.patronymic ILIKE '%' || p_search_text || '%' OR
        p.biography ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, p.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_persons_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 18:51:21,835 - data_access.base_repository - ERROR - Error executing function sp_search_persons_fulltext: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 11.
CONTEXT:  SQL-оператор: "SELECT 
        p.person_id,
        p.name,
        p.surname,
        p.patronymic,
        TRIM(CONCAT(p.name, ' ', COALESCE(p.surname, ''), ' ', COALESCE(p.patronymic, ''))) as full_name,
        p.date_of_birth,
        p.date_of_death,
        CASE 
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - ', EXTRACT(YEAR FROM p.date_of_death))
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - н.в.')
            ELSE '? - ?'
        END as life_years,
        p.biography,
        c.name as country_name,
        (
            CASE WHEN p.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p.surname ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN p.patronymic ILIKE '%' || p_search_text || '%' THEN 1.5 ELSE 0.0 END +
            CASE WHEN p.biography ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.persons p
    LEFT JOIN public.countries c ON p.country_id = c.country_id
    WHERE 
        p.name ILIKE '%' || p_search_text || '%' OR 
        p.surname ILIKE '%' || p_search_text || '%' OR
        p.patronymic ILIKE '%' || p_search_text || '%' OR
        p.biography ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, p.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_persons_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 18:51:32,031 - core.database - ERROR - Error executing function sp_search_persons_fulltext with params ('Ленин', 0, 20): structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 11.
CONTEXT:  SQL-оператор: "SELECT 
        p.person_id,
        p.name,
        p.surname,
        p.patronymic,
        TRIM(CONCAT(p.name, ' ', COALESCE(p.surname, ''), ' ', COALESCE(p.patronymic, ''))) as full_name,
        p.date_of_birth,
        p.date_of_death,
        CASE 
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - ', EXTRACT(YEAR FROM p.date_of_death))
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - н.в.')
            ELSE '? - ?'
        END as life_years,
        p.biography,
        c.name as country_name,
        (
            CASE WHEN p.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p.surname ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN p.patronymic ILIKE '%' || p_search_text || '%' THEN 1.5 ELSE 0.0 END +
            CASE WHEN p.biography ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.persons p
    LEFT JOIN public.countries c ON p.country_id = c.country_id
    WHERE 
        p.name ILIKE '%' || p_search_text || '%' OR 
        p.surname ILIKE '%' || p_search_text || '%' OR
        p.patronymic ILIKE '%' || p_search_text || '%' OR
        p.biography ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, p.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_persons_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 18:51:32,031 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 11.
CONTEXT:  SQL-оператор: "SELECT 
        p.person_id,
        p.name,
        p.surname,
        p.patronymic,
        TRIM(CONCAT(p.name, ' ', COALESCE(p.surname, ''), ' ', COALESCE(p.patronymic, ''))) as full_name,
        p.date_of_birth,
        p.date_of_death,
        CASE 
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - ', EXTRACT(YEAR FROM p.date_of_death))
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - н.в.')
            ELSE '? - ?'
        END as life_years,
        p.biography,
        c.name as country_name,
        (
            CASE WHEN p.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p.surname ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN p.patronymic ILIKE '%' || p_search_text || '%' THEN 1.5 ELSE 0.0 END +
            CASE WHEN p.biography ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.persons p
    LEFT JOIN public.countries c ON p.country_id = c.country_id
    WHERE 
        p.name ILIKE '%' || p_search_text || '%' OR 
        p.surname ILIKE '%' || p_search_text || '%' OR
        p.patronymic ILIKE '%' || p_search_text || '%' OR
        p.biography ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, p.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_persons_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 18:51:32,032 - data_access.base_repository - ERROR - Error executing function sp_search_persons_fulltext: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 11.
CONTEXT:  SQL-оператор: "SELECT 
        p.person_id,
        p.name,
        p.surname,
        p.patronymic,
        TRIM(CONCAT(p.name, ' ', COALESCE(p.surname, ''), ' ', COALESCE(p.patronymic, ''))) as full_name,
        p.date_of_birth,
        p.date_of_death,
        CASE 
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - ', EXTRACT(YEAR FROM p.date_of_death))
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - н.в.')
            ELSE '? - ?'
        END as life_years,
        p.biography,
        c.name as country_name,
        (
            CASE WHEN p.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p.surname ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN p.patronymic ILIKE '%' || p_search_text || '%' THEN 1.5 ELSE 0.0 END +
            CASE WHEN p.biography ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.persons p
    LEFT JOIN public.countries c ON p.country_id = c.country_id
    WHERE 
        p.name ILIKE '%' || p_search_text || '%' OR 
        p.surname ILIKE '%' || p_search_text || '%' OR
        p.patronymic ILIKE '%' || p_search_text || '%' OR
        p.biography ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, p.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_persons_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 18:53:33,060 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:53:47,422 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 18:57:00,873 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:57:06,381 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:57:07,822 - __main__ - INFO - Login cancelled by user
2025-05-29 18:57:07,824 - core.database - INFO - Database connection pool closed
2025-05-29 18:57:11,582 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 18:57:24,461 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:01:51,471 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:02:00,429 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:03:32,212 - core.database - INFO - Database connection pool closed
2025-05-29 19:05:32,391 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:05:40,922 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:06:17,421 - core.database - ERROR - Error executing function sp_create_source_direct with params (3, 'Союз Советских Социалистических Республи', 'Кто-то', PyQt6.QtCore.QDate(2025, 5, 21), 'Статья', 'https://ru.wikipedia.org/wiki/Союз_Советских_Социалистических_Республик'): cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 19:06:17,422 - core.database - ERROR - Database error: cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 19:06:17,422 - data_access.base_repository - ERROR - Error executing function sp_create_source_direct: cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 19:06:35,146 - core.database - ERROR - Error executing function sp_create_source_direct with params (3, 'Союз Советских Социалистических Республи', 'Кто-то', PyQt6.QtCore.QDate(2025, 5, 21), 'Статья', 'https://ru.wikipedia.org/wiki/Союз_Советских_Социалистических_Республик'): cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 19:06:35,146 - core.database - ERROR - Database error: cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 19:06:35,147 - data_access.base_repository - ERROR - Error executing function sp_create_source_direct: cannot adapt type 'QDate' using placeholder '%s' (format: AUTO)
2025-05-29 19:07:10,766 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:07:20,817 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:08:52,669 - core.database - ERROR - Error executing function sp_get_events_hierarchy with params (None, 3): в рекурсивном запросе "event_tree" столбец 10 имеет тип character varying(255) в нерекурсивной части, но в результате тип character varying
LINE 13:             e.name as path
                     ^
HINT:  Приведите результат нерекурсивной части к правильному типу.
QUERY:  WITH RECURSIVE event_tree AS (
        -- Начальный уровень
        SELECT 
            e.event_id,
            e.name,
            e.description,
            e.start_date,
            e.end_date,
            e.location,
            e.event_type,
            e.parent_id,
            0 as level,
            e.name as path
        FROM public.events e
        WHERE (p_parent_id IS NULL AND e.parent_id IS NULL) OR e.parent_id = p_parent_id
        
        UNION ALL
        
        -- Рекурсивная часть
        SELECT 
            e.event_id,
            e.name,
            e.description,
            e.start_date,
            e.end_date,
            e.location,
            e.event_type,
            e.parent_id,
            et.level + 1,
            CONCAT(et.path, ' > ', e.name)
        FROM public.events e
        JOIN event_tree et ON e.parent_id = et.event_id
        WHERE et.level < p_max_levels
    )
    SELECT 
        et.event_id,
        et.name,
        et.description,
        et.start_date,
        et.end_date,
        CASE 
            WHEN et.start_date IS NOT NULL AND et.end_date IS NOT NULL THEN
                CASE 
                    WHEN et.start_date = et.end_date THEN
                        TO_CHAR(et.start_date, 'DD.MM.YYYY')
                    ELSE
                        CONCAT(TO_CHAR(et.start_date, 'DD.MM.YYYY'), ' - ', TO_CHAR(et.end_date, 'DD.MM.YYYY'))
                END
            WHEN et.start_date IS NOT NULL AND et.end_date IS NULL THEN
                CONCAT('с ', TO_CHAR(et.start_date, 'DD.MM.YYYY'))
            WHEN et.start_date IS NULL AND et.end_date IS NOT NULL THEN
                CONCAT('до ', TO_CHAR(et.end_date, 'DD.MM.YYYY'))
            ELSE 'период неизвестен'
        END as period_text,
        et.location,
        et.event_type,
        et.parent_id,
        et.level,
        et.path,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = et.event_id) as children_count,
        EXISTS (SELECT 1 FROM public.events ce WHERE ce.parent_id = et.event_id) as has_children
    FROM event_tree et
    ORDER BY et.level, COALESCE(et.start_date, '1900-01-01'::date), et.name
CONTEXT:  функция PL/pgSQL sp_get_events_hierarchy(integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:08:52,670 - core.database - ERROR - Database error: в рекурсивном запросе "event_tree" столбец 10 имеет тип character varying(255) в нерекурсивной части, но в результате тип character varying
LINE 13:             e.name as path
                     ^
HINT:  Приведите результат нерекурсивной части к правильному типу.
QUERY:  WITH RECURSIVE event_tree AS (
        -- Начальный уровень
        SELECT 
            e.event_id,
            e.name,
            e.description,
            e.start_date,
            e.end_date,
            e.location,
            e.event_type,
            e.parent_id,
            0 as level,
            e.name as path
        FROM public.events e
        WHERE (p_parent_id IS NULL AND e.parent_id IS NULL) OR e.parent_id = p_parent_id
        
        UNION ALL
        
        -- Рекурсивная часть
        SELECT 
            e.event_id,
            e.name,
            e.description,
            e.start_date,
            e.end_date,
            e.location,
            e.event_type,
            e.parent_id,
            et.level + 1,
            CONCAT(et.path, ' > ', e.name)
        FROM public.events e
        JOIN event_tree et ON e.parent_id = et.event_id
        WHERE et.level < p_max_levels
    )
    SELECT 
        et.event_id,
        et.name,
        et.description,
        et.start_date,
        et.end_date,
        CASE 
            WHEN et.start_date IS NOT NULL AND et.end_date IS NOT NULL THEN
                CASE 
                    WHEN et.start_date = et.end_date THEN
                        TO_CHAR(et.start_date, 'DD.MM.YYYY')
                    ELSE
                        CONCAT(TO_CHAR(et.start_date, 'DD.MM.YYYY'), ' - ', TO_CHAR(et.end_date, 'DD.MM.YYYY'))
                END
            WHEN et.start_date IS NOT NULL AND et.end_date IS NULL THEN
                CONCAT('с ', TO_CHAR(et.start_date, 'DD.MM.YYYY'))
            WHEN et.start_date IS NULL AND et.end_date IS NOT NULL THEN
                CONCAT('до ', TO_CHAR(et.end_date, 'DD.MM.YYYY'))
            ELSE 'период неизвестен'
        END as period_text,
        et.location,
        et.event_type,
        et.parent_id,
        et.level,
        et.path,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = et.event_id) as children_count,
        EXISTS (SELECT 1 FROM public.events ce WHERE ce.parent_id = et.event_id) as has_children
    FROM event_tree et
    ORDER BY et.level, COALESCE(et.start_date, '1900-01-01'::date), et.name
CONTEXT:  функция PL/pgSQL sp_get_events_hierarchy(integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:08:52,671 - data_access.base_repository - ERROR - Error executing function sp_get_events_hierarchy: в рекурсивном запросе "event_tree" столбец 10 имеет тип character varying(255) в нерекурсивной части, но в результате тип character varying
LINE 13:             e.name as path
                     ^
HINT:  Приведите результат нерекурсивной части к правильному типу.
QUERY:  WITH RECURSIVE event_tree AS (
        -- Начальный уровень
        SELECT 
            e.event_id,
            e.name,
            e.description,
            e.start_date,
            e.end_date,
            e.location,
            e.event_type,
            e.parent_id,
            0 as level,
            e.name as path
        FROM public.events e
        WHERE (p_parent_id IS NULL AND e.parent_id IS NULL) OR e.parent_id = p_parent_id
        
        UNION ALL
        
        -- Рекурсивная часть
        SELECT 
            e.event_id,
            e.name,
            e.description,
            e.start_date,
            e.end_date,
            e.location,
            e.event_type,
            e.parent_id,
            et.level + 1,
            CONCAT(et.path, ' > ', e.name)
        FROM public.events e
        JOIN event_tree et ON e.parent_id = et.event_id
        WHERE et.level < p_max_levels
    )
    SELECT 
        et.event_id,
        et.name,
        et.description,
        et.start_date,
        et.end_date,
        CASE 
            WHEN et.start_date IS NOT NULL AND et.end_date IS NOT NULL THEN
                CASE 
                    WHEN et.start_date = et.end_date THEN
                        TO_CHAR(et.start_date, 'DD.MM.YYYY')
                    ELSE
                        CONCAT(TO_CHAR(et.start_date, 'DD.MM.YYYY'), ' - ', TO_CHAR(et.end_date, 'DD.MM.YYYY'))
                END
            WHEN et.start_date IS NOT NULL AND et.end_date IS NULL THEN
                CONCAT('с ', TO_CHAR(et.start_date, 'DD.MM.YYYY'))
            WHEN et.start_date IS NULL AND et.end_date IS NOT NULL THEN
                CONCAT('до ', TO_CHAR(et.end_date, 'DD.MM.YYYY'))
            ELSE 'период неизвестен'
        END as period_text,
        et.location,
        et.event_type,
        et.parent_id,
        et.level,
        et.path,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = et.event_id) as children_count,
        EXISTS (SELECT 1 FROM public.events ce WHERE ce.parent_id = et.event_id) as has_children
    FROM event_tree et
    ORDER BY et.level, COALESCE(et.start_date, '1900-01-01'::date), et.name
CONTEXT:  функция PL/pgSQL sp_get_events_hierarchy(integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:09:22,388 - core.database - INFO - Database connection pool closed
2025-05-29 19:09:29,569 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:09:39,386 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:15:50,599 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:15:59,374 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:16:58,430 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:17:08,077 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:18:36,885 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:18:43,995 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:21:28,139 - core.database - ERROR - Error executing function sp_check_sources_urls with params None: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 5.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.url,
        CASE 
            WHEN s.url IS NULL OR LENGTH(s.url) = 0 THEN 'NO_URL'
            WHEN s.url NOT ILIKE 'http://%' AND s.url NOT ILIKE 'https://%' AND s.url NOT ILIKE 'ftp://%' THEN 'INVALID_PROTOCOL'
            WHEN LENGTH(s.url) > 500 THEN 'TOO_LONG'
            WHEN s.url !~ '^https?://[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*' THEN 'INVALID_FORMAT'
            ELSE 'VALID'
        END as url_status,
        CASE 
            WHEN s.url IS NULL OR LENGTH(s.url) = 0 THEN 'URL не указан'
            WHEN s.url NOT ILIKE 'http://%' AND s.url NOT ILIKE 'https://%' AND s.url NOT ILIKE 'ftp://%' THEN 'Отсутствует протокол (http/https)'
            WHEN LENGTH(s.url) > 500 THEN 'URL слишком длинный'
            WHEN s.url !~ '^https?://[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*' THEN 'Некорректный формат URL'
            ELSE 'URL корректен'
        END as issue_description
    FROM public.sources s
    ORDER BY 
        CASE 
            WHEN s.url IS NULL OR LENGTH(s.url) = 0 THEN 1
            WHEN s.url NOT ILIKE 'http://%' AND s.url NOT ILIKE 'https://%' AND s.url NOT ILIKE 'ftp://%' THEN 2
            WHEN LENGTH(s.url) > 500 THEN 3
            WHEN s.url !~ '^https?://[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*' THEN 4
            ELSE 5
        END,
        s.name"
функция PL/pgSQL sp_check_sources_urls(), строка 3, оператор RETURN QUERY
2025-05-29 19:21:28,140 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 5.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.url,
        CASE 
            WHEN s.url IS NULL OR LENGTH(s.url) = 0 THEN 'NO_URL'
            WHEN s.url NOT ILIKE 'http://%' AND s.url NOT ILIKE 'https://%' AND s.url NOT ILIKE 'ftp://%' THEN 'INVALID_PROTOCOL'
            WHEN LENGTH(s.url) > 500 THEN 'TOO_LONG'
            WHEN s.url !~ '^https?://[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*' THEN 'INVALID_FORMAT'
            ELSE 'VALID'
        END as url_status,
        CASE 
            WHEN s.url IS NULL OR LENGTH(s.url) = 0 THEN 'URL не указан'
            WHEN s.url NOT ILIKE 'http://%' AND s.url NOT ILIKE 'https://%' AND s.url NOT ILIKE 'ftp://%' THEN 'Отсутствует протокол (http/https)'
            WHEN LENGTH(s.url) > 500 THEN 'URL слишком длинный'
            WHEN s.url !~ '^https?://[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*' THEN 'Некорректный формат URL'
            ELSE 'URL корректен'
        END as issue_description
    FROM public.sources s
    ORDER BY 
        CASE 
            WHEN s.url IS NULL OR LENGTH(s.url) = 0 THEN 1
            WHEN s.url NOT ILIKE 'http://%' AND s.url NOT ILIKE 'https://%' AND s.url NOT ILIKE 'ftp://%' THEN 2
            WHEN LENGTH(s.url) > 500 THEN 3
            WHEN s.url !~ '^https?://[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*' THEN 4
            ELSE 5
        END,
        s.name"
функция PL/pgSQL sp_check_sources_urls(), строка 3, оператор RETURN QUERY
2025-05-29 19:21:28,140 - data_access.base_repository - ERROR - Error executing function sp_check_sources_urls: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 5.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.url,
        CASE 
            WHEN s.url IS NULL OR LENGTH(s.url) = 0 THEN 'NO_URL'
            WHEN s.url NOT ILIKE 'http://%' AND s.url NOT ILIKE 'https://%' AND s.url NOT ILIKE 'ftp://%' THEN 'INVALID_PROTOCOL'
            WHEN LENGTH(s.url) > 500 THEN 'TOO_LONG'
            WHEN s.url !~ '^https?://[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*' THEN 'INVALID_FORMAT'
            ELSE 'VALID'
        END as url_status,
        CASE 
            WHEN s.url IS NULL OR LENGTH(s.url) = 0 THEN 'URL не указан'
            WHEN s.url NOT ILIKE 'http://%' AND s.url NOT ILIKE 'https://%' AND s.url NOT ILIKE 'ftp://%' THEN 'Отсутствует протокол (http/https)'
            WHEN LENGTH(s.url) > 500 THEN 'URL слишком длинный'
            WHEN s.url !~ '^https?://[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*' THEN 'Некорректный формат URL'
            ELSE 'URL корректен'
        END as issue_description
    FROM public.sources s
    ORDER BY 
        CASE 
            WHEN s.url IS NULL OR LENGTH(s.url) = 0 THEN 1
            WHEN s.url NOT ILIKE 'http://%' AND s.url NOT ILIKE 'https://%' AND s.url NOT ILIKE 'ftp://%' THEN 2
            WHEN LENGTH(s.url) > 500 THEN 3
            WHEN s.url !~ '^https?://[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*' THEN 4
            ELSE 5
        END,
        s.name"
функция PL/pgSQL sp_check_sources_urls(), строка 3, оператор RETURN QUERY
2025-05-29 19:28:43,925 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:28:54,695 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:29:10,886 - core.database - ERROR - Error executing function sp_find_duplicate_sources with params None: неоднозначная ссылка на столбец "name"
LINE 3:             LOWER(name) as name_lower,
                          ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH duplicate_groups AS (
        SELECT 
            LOWER(name) as name_lower,
            COALESCE(LOWER(author), '') as author_lower,
            COUNT(*) as cnt,
            ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, LOWER(name)) as group_id
        FROM public.sources
        GROUP BY LOWER(name), COALESCE(LOWER(author), '')
        HAVING COUNT(*) > 1
    )
    SELECT 
        dg.group_id::integer,
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        s.type,
        s.url,
        dg.cnt as duplicates_count
    FROM public.sources s
    JOIN duplicate_groups dg ON LOWER(s.name) = dg.name_lower 
                            AND COALESCE(LOWER(s.author), '') = dg.author_lower
    ORDER BY dg.group_id, s.publication_date, s.source_id
CONTEXT:  функция PL/pgSQL sp_find_duplicate_sources(), строка 3, оператор RETURN QUERY
2025-05-29 19:29:10,886 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "name"
LINE 3:             LOWER(name) as name_lower,
                          ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH duplicate_groups AS (
        SELECT 
            LOWER(name) as name_lower,
            COALESCE(LOWER(author), '') as author_lower,
            COUNT(*) as cnt,
            ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, LOWER(name)) as group_id
        FROM public.sources
        GROUP BY LOWER(name), COALESCE(LOWER(author), '')
        HAVING COUNT(*) > 1
    )
    SELECT 
        dg.group_id::integer,
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        s.type,
        s.url,
        dg.cnt as duplicates_count
    FROM public.sources s
    JOIN duplicate_groups dg ON LOWER(s.name) = dg.name_lower 
                            AND COALESCE(LOWER(s.author), '') = dg.author_lower
    ORDER BY dg.group_id, s.publication_date, s.source_id
CONTEXT:  функция PL/pgSQL sp_find_duplicate_sources(), строка 3, оператор RETURN QUERY
2025-05-29 19:29:10,887 - data_access.base_repository - ERROR - Error executing function sp_find_duplicate_sources: неоднозначная ссылка на столбец "name"
LINE 3:             LOWER(name) as name_lower,
                          ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH duplicate_groups AS (
        SELECT 
            LOWER(name) as name_lower,
            COALESCE(LOWER(author), '') as author_lower,
            COUNT(*) as cnt,
            ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, LOWER(name)) as group_id
        FROM public.sources
        GROUP BY LOWER(name), COALESCE(LOWER(author), '')
        HAVING COUNT(*) > 1
    )
    SELECT 
        dg.group_id::integer,
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        s.type,
        s.url,
        dg.cnt as duplicates_count
    FROM public.sources s
    JOIN duplicate_groups dg ON LOWER(s.name) = dg.name_lower 
                            AND COALESCE(LOWER(s.author), '') = dg.author_lower
    ORDER BY dg.group_id, s.publication_date, s.source_id
CONTEXT:  функция PL/pgSQL sp_find_duplicate_sources(), строка 3, оператор RETURN QUERY
2025-05-29 19:30:08,897 - core.database - INFO - Database connection pool closed
2025-05-29 19:31:26,239 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:31:34,016 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:31:37,609 - core.database - ERROR - Error executing function sp_get_source_by_id with params (1,): structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:31:37,610 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:31:37,611 - data_access.base_repository - ERROR - Error executing function sp_get_source_by_id: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:31:55,479 - core.database - ERROR - Error executing function sp_get_source_by_id with params (1,): structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:31:55,479 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:31:55,480 - data_access.base_repository - ERROR - Error executing function sp_get_source_by_id: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:32:08,954 - core.database - ERROR - Error executing function sp_get_source_by_id with params (1,): structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:32:08,955 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:32:08,955 - data_access.base_repository - ERROR - Error executing function sp_get_source_by_id: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:34:33,567 - core.database - ERROR - Error executing function sp_get_source_by_id with params (1,): structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:34:33,567 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:34:33,568 - data_access.base_repository - ERROR - Error executing function sp_get_source_by_id: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:35:05,180 - core.database - ERROR - Error executing function sp_get_source_by_id with params (1,): structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:35:05,180 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:35:05,181 - data_access.base_repository - ERROR - Error executing function sp_get_source_by_id: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:35:12,528 - core.database - ERROR - Error executing function sp_get_source_by_id with params (1,): structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:35:12,529 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:35:12,529 - data_access.base_repository - ERROR - Error executing function sp_get_source_by_id: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT 
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE 
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE 
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND 
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE 
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:35:40,629 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:35:42,238 - __main__ - INFO - Login cancelled by user
2025-05-29 19:35:42,239 - core.database - INFO - Database connection pool closed
2025-05-29 19:37:39,963 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:37:48,122 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:37:50,451 - core.database - ERROR - Error executing function sp_get_source_by_id with params (1,): structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 2, оператор RETURN QUERY
2025-05-29 19:37:50,452 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 2, оператор RETURN QUERY
2025-05-29 19:37:50,452 - data_access.base_repository - ERROR - Error executing function sp_get_source_by_id: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 2, оператор RETURN QUERY
2025-05-29 19:38:11,790 - core.database - ERROR - Error executing function sp_get_source_by_id with params (1,): в запросе нет назначения для данных результата
HINT:  Если вам нужно отбросить результаты SELECT, используйте PERFORM.
CONTEXT:  функция PL/pgSQL sp_get_source_by_id(integer), строка 2, оператор SQL-оператор
2025-05-29 19:38:11,790 - core.database - ERROR - Database error: в запросе нет назначения для данных результата
HINT:  Если вам нужно отбросить результаты SELECT, используйте PERFORM.
CONTEXT:  функция PL/pgSQL sp_get_source_by_id(integer), строка 2, оператор SQL-оператор
2025-05-29 19:38:11,790 - data_access.base_repository - ERROR - Error executing function sp_get_source_by_id: в запросе нет назначения для данных результата
HINT:  Если вам нужно отбросить результаты SELECT, используйте PERFORM.
CONTEXT:  функция PL/pgSQL sp_get_source_by_id(integer), строка 2, оператор SQL-оператор
2025-05-29 19:38:48,841 - core.database - ERROR - Error executing function sp_get_source_by_id with params (1,): structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 2, оператор RETURN QUERY
2025-05-29 19:38:48,842 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 2, оператор RETURN QUERY
2025-05-29 19:38:48,842 - data_access.base_repository - ERROR - Error executing function sp_get_source_by_id: structure of query does not match function result type
DETAIL:  Возвращаемый тип text не соответствует ожидаемому типу character varying в столбце 10.
CONTEXT:  SQL-оператор: "SELECT
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        EXTRACT(YEAR FROM s.publication_date)::integer as publication_year,
        CASE
            WHEN s.publication_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM s.publication_date)::integer
            ELSE NULL
        END as age_years,
        s.type,
        s.url,
        CASE
            WHEN s.url IS NOT NULL AND LENGTH(TRIM(s.url)) > 0 AND
                 (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN true
            ELSE false
        END as has_valid_url,
        CASE
            WHEN s.url IS NOT NULL AND (s.url ILIKE 'http://%' OR s.url ILIKE 'https://%') THEN
                split_part(split_part(s.url, '://', 2), '/', 1)
            ELSE NULL
        END as url_domain,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.source_id = s.source_id) as events_count
    FROM public.sources s
    WHERE s.source_id = p_source_id"
функция PL/pgSQL sp_get_source_by_id(integer), строка 2, оператор RETURN QUERY
2025-05-29 19:40:55,606 - core.database - ERROR - Error executing function sp_find_duplicate_sources with params None: неоднозначная ссылка на столбец "name"
LINE 3:             LOWER(name) as name_lower,
                          ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH duplicate_groups AS (
        SELECT 
            LOWER(name) as name_lower,
            COALESCE(LOWER(author), '') as author_lower,
            COUNT(*) as cnt,
            ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, LOWER(name)) as group_id
        FROM public.sources
        GROUP BY LOWER(name), COALESCE(LOWER(author), '')
        HAVING COUNT(*) > 1
    )
    SELECT 
        dg.group_id::integer,
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        s.type,
        s.url,
        dg.cnt as duplicates_count
    FROM public.sources s
    JOIN duplicate_groups dg ON LOWER(s.name) = dg.name_lower 
                            AND COALESCE(LOWER(s.author), '') = dg.author_lower
    ORDER BY dg.group_id, s.publication_date, s.source_id
CONTEXT:  функция PL/pgSQL sp_find_duplicate_sources(), строка 3, оператор RETURN QUERY
2025-05-29 19:40:55,606 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "name"
LINE 3:             LOWER(name) as name_lower,
                          ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH duplicate_groups AS (
        SELECT 
            LOWER(name) as name_lower,
            COALESCE(LOWER(author), '') as author_lower,
            COUNT(*) as cnt,
            ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, LOWER(name)) as group_id
        FROM public.sources
        GROUP BY LOWER(name), COALESCE(LOWER(author), '')
        HAVING COUNT(*) > 1
    )
    SELECT 
        dg.group_id::integer,
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        s.type,
        s.url,
        dg.cnt as duplicates_count
    FROM public.sources s
    JOIN duplicate_groups dg ON LOWER(s.name) = dg.name_lower 
                            AND COALESCE(LOWER(s.author), '') = dg.author_lower
    ORDER BY dg.group_id, s.publication_date, s.source_id
CONTEXT:  функция PL/pgSQL sp_find_duplicate_sources(), строка 3, оператор RETURN QUERY
2025-05-29 19:40:55,607 - data_access.base_repository - ERROR - Error executing function sp_find_duplicate_sources: неоднозначная ссылка на столбец "name"
LINE 3:             LOWER(name) as name_lower,
                          ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH duplicate_groups AS (
        SELECT 
            LOWER(name) as name_lower,
            COALESCE(LOWER(author), '') as author_lower,
            COUNT(*) as cnt,
            ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, LOWER(name)) as group_id
        FROM public.sources
        GROUP BY LOWER(name), COALESCE(LOWER(author), '')
        HAVING COUNT(*) > 1
    )
    SELECT 
        dg.group_id::integer,
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        s.type,
        s.url,
        dg.cnt as duplicates_count
    FROM public.sources s
    JOIN duplicate_groups dg ON LOWER(s.name) = dg.name_lower 
                            AND COALESCE(LOWER(s.author), '') = dg.author_lower
    ORDER BY dg.group_id, s.publication_date, s.source_id
CONTEXT:  функция PL/pgSQL sp_find_duplicate_sources(), строка 3, оператор RETURN QUERY
2025-05-29 19:40:58,894 - core.database - ERROR - Error executing function sp_find_duplicate_sources with params None: неоднозначная ссылка на столбец "name"
LINE 3:             LOWER(name) as name_lower,
                          ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH duplicate_groups AS (
        SELECT 
            LOWER(name) as name_lower,
            COALESCE(LOWER(author), '') as author_lower,
            COUNT(*) as cnt,
            ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, LOWER(name)) as group_id
        FROM public.sources
        GROUP BY LOWER(name), COALESCE(LOWER(author), '')
        HAVING COUNT(*) > 1
    )
    SELECT 
        dg.group_id::integer,
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        s.type,
        s.url,
        dg.cnt as duplicates_count
    FROM public.sources s
    JOIN duplicate_groups dg ON LOWER(s.name) = dg.name_lower 
                            AND COALESCE(LOWER(s.author), '') = dg.author_lower
    ORDER BY dg.group_id, s.publication_date, s.source_id
CONTEXT:  функция PL/pgSQL sp_find_duplicate_sources(), строка 3, оператор RETURN QUERY
2025-05-29 19:40:58,895 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "name"
LINE 3:             LOWER(name) as name_lower,
                          ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH duplicate_groups AS (
        SELECT 
            LOWER(name) as name_lower,
            COALESCE(LOWER(author), '') as author_lower,
            COUNT(*) as cnt,
            ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, LOWER(name)) as group_id
        FROM public.sources
        GROUP BY LOWER(name), COALESCE(LOWER(author), '')
        HAVING COUNT(*) > 1
    )
    SELECT 
        dg.group_id::integer,
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        s.type,
        s.url,
        dg.cnt as duplicates_count
    FROM public.sources s
    JOIN duplicate_groups dg ON LOWER(s.name) = dg.name_lower 
                            AND COALESCE(LOWER(s.author), '') = dg.author_lower
    ORDER BY dg.group_id, s.publication_date, s.source_id
CONTEXT:  функция PL/pgSQL sp_find_duplicate_sources(), строка 3, оператор RETURN QUERY
2025-05-29 19:40:58,895 - data_access.base_repository - ERROR - Error executing function sp_find_duplicate_sources: неоднозначная ссылка на столбец "name"
LINE 3:             LOWER(name) as name_lower,
                          ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH duplicate_groups AS (
        SELECT 
            LOWER(name) as name_lower,
            COALESCE(LOWER(author), '') as author_lower,
            COUNT(*) as cnt,
            ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC, LOWER(name)) as group_id
        FROM public.sources
        GROUP BY LOWER(name), COALESCE(LOWER(author), '')
        HAVING COUNT(*) > 1
    )
    SELECT 
        dg.group_id::integer,
        s.source_id,
        s.name,
        s.author,
        s.publication_date,
        s.type,
        s.url,
        dg.cnt as duplicates_count
    FROM public.sources s
    JOIN duplicate_groups dg ON LOWER(s.name) = dg.name_lower 
                            AND COALESCE(LOWER(s.author), '') = dg.author_lower
    ORDER BY dg.group_id, s.publication_date, s.source_id
CONTEXT:  функция PL/pgSQL sp_find_duplicate_sources(), строка 3, оператор RETURN QUERY
2025-05-29 19:41:04,781 - core.database - ERROR - Error executing function sp_search_persons_fulltext with params ('фывф', 0, 20): structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 11.
CONTEXT:  SQL-оператор: "SELECT 
        p.person_id,
        p.name,
        p.surname,
        p.patronymic,
        TRIM(CONCAT(p.name, ' ', COALESCE(p.surname, ''), ' ', COALESCE(p.patronymic, ''))) as full_name,
        p.date_of_birth,
        p.date_of_death,
        CASE 
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - ', EXTRACT(YEAR FROM p.date_of_death))
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - н.в.')
            ELSE '? - ?'
        END as life_years,
        p.biography,
        c.name as country_name,
        (
            CASE WHEN p.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p.surname ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN p.patronymic ILIKE '%' || p_search_text || '%' THEN 1.5 ELSE 0.0 END +
            CASE WHEN p.biography ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.persons p
    LEFT JOIN public.countries c ON p.country_id = c.country_id
    WHERE 
        p.name ILIKE '%' || p_search_text || '%' OR 
        p.surname ILIKE '%' || p_search_text || '%' OR
        p.patronymic ILIKE '%' || p_search_text || '%' OR
        p.biography ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, p.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_persons_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:41:04,782 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 11.
CONTEXT:  SQL-оператор: "SELECT 
        p.person_id,
        p.name,
        p.surname,
        p.patronymic,
        TRIM(CONCAT(p.name, ' ', COALESCE(p.surname, ''), ' ', COALESCE(p.patronymic, ''))) as full_name,
        p.date_of_birth,
        p.date_of_death,
        CASE 
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - ', EXTRACT(YEAR FROM p.date_of_death))
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - н.в.')
            ELSE '? - ?'
        END as life_years,
        p.biography,
        c.name as country_name,
        (
            CASE WHEN p.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p.surname ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN p.patronymic ILIKE '%' || p_search_text || '%' THEN 1.5 ELSE 0.0 END +
            CASE WHEN p.biography ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.persons p
    LEFT JOIN public.countries c ON p.country_id = c.country_id
    WHERE 
        p.name ILIKE '%' || p_search_text || '%' OR 
        p.surname ILIKE '%' || p_search_text || '%' OR
        p.patronymic ILIKE '%' || p_search_text || '%' OR
        p.biography ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, p.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_persons_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:41:04,782 - data_access.base_repository - ERROR - Error executing function sp_search_persons_fulltext: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 11.
CONTEXT:  SQL-оператор: "SELECT 
        p.person_id,
        p.name,
        p.surname,
        p.patronymic,
        TRIM(CONCAT(p.name, ' ', COALESCE(p.surname, ''), ' ', COALESCE(p.patronymic, ''))) as full_name,
        p.date_of_birth,
        p.date_of_death,
        CASE 
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - ', EXTRACT(YEAR FROM p.date_of_death))
            WHEN p.date_of_birth IS NOT NULL AND p.date_of_death IS NULL THEN
                CONCAT(EXTRACT(YEAR FROM p.date_of_birth), ' - н.в.')
            ELSE '? - ?'
        END as life_years,
        p.biography,
        c.name as country_name,
        (
            CASE WHEN p.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p.surname ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN p.patronymic ILIKE '%' || p_search_text || '%' THEN 1.5 ELSE 0.0 END +
            CASE WHEN p.biography ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.persons p
    LEFT JOIN public.countries c ON p.country_id = c.country_id
    WHERE 
        p.name ILIKE '%' || p_search_text || '%' OR 
        p.surname ILIKE '%' || p_search_text || '%' OR
        p.patronymic ILIKE '%' || p_search_text || '%' OR
        p.biography ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, p.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_persons_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:42:55,173 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:43:02,805 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:43:07,299 - core.database - ERROR - Error executing function sp_get_event_by_id with params (1,): в рекурсивном запросе "event_path" столбец 5 имеет тип character varying(255) в нерекурсивной части, но в результате тип character varying
LINE 8:             e.name as path
                    ^
HINT:  Приведите результат нерекурсивной части к правильному типу.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT 
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        SELECT 
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            CONCAT(pe.name, ' > ', ep.path)
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT 
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE 
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        CONCAT(TO_CHAR(e.start_date, 'DD.MM.YYYY'), ' - ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                CONCAT('с ', TO_CHAR(e.start_date, 'DD.MM.YYYY'))
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                CONCAT('до ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
            ELSE 'период неизвестен'
        END as period_text,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:43:07,300 - core.database - ERROR - Database error: в рекурсивном запросе "event_path" столбец 5 имеет тип character varying(255) в нерекурсивной части, но в результате тип character varying
LINE 8:             e.name as path
                    ^
HINT:  Приведите результат нерекурсивной части к правильному типу.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT 
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        SELECT 
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            CONCAT(pe.name, ' > ', ep.path)
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT 
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE 
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        CONCAT(TO_CHAR(e.start_date, 'DD.MM.YYYY'), ' - ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                CONCAT('с ', TO_CHAR(e.start_date, 'DD.MM.YYYY'))
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                CONCAT('до ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
            ELSE 'период неизвестен'
        END as period_text,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:43:07,301 - data_access.base_repository - ERROR - Error executing function sp_get_event_by_id: в рекурсивном запросе "event_path" столбец 5 имеет тип character varying(255) в нерекурсивной части, но в результате тип character varying
LINE 8:             e.name as path
                    ^
HINT:  Приведите результат нерекурсивной части к правильному типу.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT 
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        SELECT 
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            CONCAT(pe.name, ' > ', ep.path)
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT 
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE 
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        CONCAT(TO_CHAR(e.start_date, 'DD.MM.YYYY'), ' - ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                CONCAT('с ', TO_CHAR(e.start_date, 'DD.MM.YYYY'))
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                CONCAT('до ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
            ELSE 'период неизвестен'
        END as period_text,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:44:09,390 - core.database - ERROR - Error executing function sp_get_event_by_id with params (1,): в рекурсивном запросе "event_path" столбец 5 имеет тип character varying(255) в нерекурсивной части, но в результате тип character varying
LINE 8:             e.name as path
                    ^
HINT:  Приведите результат нерекурсивной части к правильному типу.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT 
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        SELECT 
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            CONCAT(pe.name, ' > ', ep.path)
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT 
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE 
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        CONCAT(TO_CHAR(e.start_date, 'DD.MM.YYYY'), ' - ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                CONCAT('с ', TO_CHAR(e.start_date, 'DD.MM.YYYY'))
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                CONCAT('до ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
            ELSE 'период неизвестен'
        END as period_text,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:44:09,391 - core.database - ERROR - Database error: в рекурсивном запросе "event_path" столбец 5 имеет тип character varying(255) в нерекурсивной части, но в результате тип character varying
LINE 8:             e.name as path
                    ^
HINT:  Приведите результат нерекурсивной части к правильному типу.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT 
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        SELECT 
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            CONCAT(pe.name, ' > ', ep.path)
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT 
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE 
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        CONCAT(TO_CHAR(e.start_date, 'DD.MM.YYYY'), ' - ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                CONCAT('с ', TO_CHAR(e.start_date, 'DD.MM.YYYY'))
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                CONCAT('до ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
            ELSE 'период неизвестен'
        END as period_text,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:44:09,392 - data_access.base_repository - ERROR - Error executing function sp_get_event_by_id: в рекурсивном запросе "event_path" столбец 5 имеет тип character varying(255) в нерекурсивной части, но в результате тип character varying
LINE 8:             e.name as path
                    ^
HINT:  Приведите результат нерекурсивной части к правильному типу.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT 
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        SELECT 
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            CONCAT(pe.name, ' > ', ep.path)
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT 
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE 
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        CONCAT(TO_CHAR(e.start_date, 'DD.MM.YYYY'), ' - ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                CONCAT('с ', TO_CHAR(e.start_date, 'DD.MM.YYYY'))
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                CONCAT('до ', TO_CHAR(e.end_date, 'DD.MM.YYYY'))
            ELSE 'период неизвестен'
        END as period_text,
        CASE 
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:44:46,062 - core.database - ERROR - Error executing function sp_get_event_by_id with params (1,): неоднозначная ссылка на столбец "parent_id"
LINE 50:         (SELECT path FROM event_path WHERE parent_id IS NULL...
                                                    ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path  -- Явное приведение к TEXT
        FROM public.events e
        WHERE e.event_id = p_event_id
        UNION ALL
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT  -- Используем оператор || вместо CONCAT и приводим к TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:44:46,063 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "parent_id"
LINE 50:         (SELECT path FROM event_path WHERE parent_id IS NULL...
                                                    ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path  -- Явное приведение к TEXT
        FROM public.events e
        WHERE e.event_id = p_event_id
        UNION ALL
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT  -- Используем оператор || вместо CONCAT и приводим к TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:44:46,064 - data_access.base_repository - ERROR - Error executing function sp_get_event_by_id: неоднозначная ссылка на столбец "parent_id"
LINE 50:         (SELECT path FROM event_path WHERE parent_id IS NULL...
                                                    ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path  -- Явное приведение к TEXT
        FROM public.events e
        WHERE e.event_id = p_event_id
        UNION ALL
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT  -- Используем оператор || вместо CONCAT и приводим к TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:44:57,680 - core.database - ERROR - Error executing function sp_get_event_by_id with params (1,): неоднозначная ссылка на столбец "parent_id"
LINE 50:         (SELECT path FROM event_path WHERE parent_id IS NULL...
                                                    ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path  -- Явное приведение к TEXT
        FROM public.events e
        WHERE e.event_id = p_event_id
        UNION ALL
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT  -- Используем оператор || вместо CONCAT и приводим к TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:44:57,681 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "parent_id"
LINE 50:         (SELECT path FROM event_path WHERE parent_id IS NULL...
                                                    ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path  -- Явное приведение к TEXT
        FROM public.events e
        WHERE e.event_id = p_event_id
        UNION ALL
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT  -- Используем оператор || вместо CONCAT и приводим к TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:44:57,681 - data_access.base_repository - ERROR - Error executing function sp_get_event_by_id: неоднозначная ссылка на столбец "parent_id"
LINE 50:         (SELECT path FROM event_path WHERE parent_id IS NULL...
                                                    ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path  -- Явное приведение к TEXT
        FROM public.events e
        WHERE e.event_id = p_event_id
        UNION ALL
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT  -- Используем оператор || вместо CONCAT и приводим к TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:49:14,319 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:49:20,698 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:49:30,096 - services.base_service - ERROR - Failed to log action: Object of type date is not JSON serializable
2025-05-29 19:52:38,380 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 19:52:47,290 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 19:53:00,493 - core.database - ERROR - Error executing function sp_get_event_by_id with params (2,): неоднозначная ссылка на столбец "parent_id"
LINE 50:         (SELECT path FROM event_path WHERE parent_id IS NULL...
                                                    ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path  -- Явное приведение к TEXT
        FROM public.events e
        WHERE e.event_id = p_event_id
        UNION ALL
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT  -- Используем оператор || вместо CONCAT и приводим к TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:53:00,494 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "parent_id"
LINE 50:         (SELECT path FROM event_path WHERE parent_id IS NULL...
                                                    ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path  -- Явное приведение к TEXT
        FROM public.events e
        WHERE e.event_id = p_event_id
        UNION ALL
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT  -- Используем оператор || вместо CONCAT и приводим к TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:53:00,496 - data_access.base_repository - ERROR - Error executing function sp_get_event_by_id: неоднозначная ссылка на столбец "parent_id"
LINE 50:         (SELECT path FROM event_path WHERE parent_id IS NULL...
                                                    ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Путь к корневому событию
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path  -- Явное приведение к TEXT
        FROM public.events e
        WHERE e.event_id = p_event_id
        UNION ALL
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT  -- Используем оператор || вместо CONCAT и приводим к TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        (SELECT path FROM event_path WHERE parent_id IS NULL) as parent_path,
        (SELECT MAX(level) FROM event_path) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:55:28,530 - core.database - ERROR - Error executing function sp_get_event_by_id with params (2,): неоднозначная ссылка на столбец "parent_id"
LINE 30:         WHERE parent_id IS NULL
                       ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Начинаем с искомого события
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        -- Поднимаемся к родительским событиям
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    ),
    -- Отдельный CTE для получения пути к корню
    root_path AS (
        SELECT 
            path as full_path,
            level
        FROM event_path 
        WHERE parent_id IS NULL
        ORDER BY level DESC
        LIMIT 1
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        COALESCE(rp.full_path, e.name) as parent_path,
        COALESCE(rp.level, 0) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    LEFT JOIN root_path rp ON TRUE  -- Соединяем с единственной записью из root_path
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:55:28,532 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "parent_id"
LINE 30:         WHERE parent_id IS NULL
                       ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Начинаем с искомого события
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        -- Поднимаемся к родительским событиям
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    ),
    -- Отдельный CTE для получения пути к корню
    root_path AS (
        SELECT 
            path as full_path,
            level
        FROM event_path 
        WHERE parent_id IS NULL
        ORDER BY level DESC
        LIMIT 1
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        COALESCE(rp.full_path, e.name) as parent_path,
        COALESCE(rp.level, 0) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    LEFT JOIN root_path rp ON TRUE  -- Соединяем с единственной записью из root_path
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:55:28,533 - data_access.base_repository - ERROR - Error executing function sp_get_event_by_id: неоднозначная ссылка на столбец "parent_id"
LINE 30:         WHERE parent_id IS NULL
                       ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Начинаем с искомого события
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        -- Поднимаемся к родительским событиям
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    ),
    -- Отдельный CTE для получения пути к корню
    root_path AS (
        SELECT 
            path as full_path,
            level
        FROM event_path 
        WHERE parent_id IS NULL
        ORDER BY level DESC
        LIMIT 1
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        COALESCE(rp.full_path, e.name) as parent_path,
        COALESCE(rp.level, 0) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    LEFT JOIN root_path rp ON TRUE  -- Соединяем с единственной записью из root_path
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:56:07,356 - core.database - ERROR - Error executing function sp_get_event_by_id with params (2,): неоднозначная ссылка на столбец "parent_id"
LINE 30:         WHERE parent_id IS NULL
                       ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Начинаем с искомого события
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        -- Поднимаемся к родительским событиям
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    ),
    -- Отдельный CTE для получения пути к корню
    root_path AS (
        SELECT 
            path as full_path,
            level
        FROM event_path 
        WHERE parent_id IS NULL
        ORDER BY level DESC
        LIMIT 1
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        COALESCE(rp.full_path, e.name) as parent_path,
        COALESCE(rp.level, 0) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    LEFT JOIN root_path rp ON TRUE  -- Соединяем с единственной записью из root_path
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:56:07,358 - core.database - ERROR - Database error: неоднозначная ссылка на столбец "parent_id"
LINE 30:         WHERE parent_id IS NULL
                       ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Начинаем с искомого события
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        -- Поднимаемся к родительским событиям
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    ),
    -- Отдельный CTE для получения пути к корню
    root_path AS (
        SELECT 
            path as full_path,
            level
        FROM event_path 
        WHERE parent_id IS NULL
        ORDER BY level DESC
        LIMIT 1
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        COALESCE(rp.full_path, e.name) as parent_path,
        COALESCE(rp.level, 0) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    LEFT JOIN root_path rp ON TRUE  -- Соединяем с единственной записью из root_path
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:56:07,359 - data_access.base_repository - ERROR - Error executing function sp_get_event_by_id: неоднозначная ссылка на столбец "parent_id"
LINE 30:         WHERE parent_id IS NULL
                       ^
DETAIL:  Подразумевается ссылка на переменную PL/pgSQL или столбец таблицы.
QUERY:  WITH RECURSIVE event_path AS (
        -- Начинаем с искомого события
        SELECT
            e.event_id,
            e.name,
            e.parent_id,
            0 as level,
            e.name::TEXT as path
        FROM public.events e
        WHERE e.event_id = p_event_id
        
        UNION ALL
        
        -- Поднимаемся к родительским событиям
        SELECT
            pe.event_id,
            pe.name,
            pe.parent_id,
            ep.level + 1,
            (pe.name || ' > ' || ep.path)::TEXT
        FROM public.events pe
        JOIN event_path ep ON pe.event_id = ep.parent_id
    ),
    -- Отдельный CTE для получения пути к корню
    root_path AS (
        SELECT 
            path as full_path,
            level
        FROM event_path 
        WHERE parent_id IS NULL
        ORDER BY level DESC
        LIMIT 1
    )
    SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        COALESCE(rp.full_path, e.name) as parent_path,
        COALESCE(rp.level, 0) as level_in_hierarchy,
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    LEFT JOIN root_path rp ON TRUE  -- Соединяем с единственной записью из root_path
    WHERE e.event_id = p_event_id
CONTEXT:  функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:57:10,695 - core.database - ERROR - Error executing function sp_get_event_by_id with params (2,): structure of query does not match function result type
DETAIL:  Возвращаемый тип character varying(255) не соответствует ожидаемому типу text в столбце 12.
CONTEXT:  SQL-оператор: "SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        COALESCE(pe.name, e.name) as parent_path,  -- Упрощенный путь
        CASE WHEN e.parent_id IS NULL THEN 0 ELSE 1 END as level_in_hierarchy,  -- Упрощенный уровень
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id"
функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:57:10,696 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип character varying(255) не соответствует ожидаемому типу text в столбце 12.
CONTEXT:  SQL-оператор: "SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        COALESCE(pe.name, e.name) as parent_path,  -- Упрощенный путь
        CASE WHEN e.parent_id IS NULL THEN 0 ELSE 1 END as level_in_hierarchy,  -- Упрощенный уровень
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id"
функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:57:10,696 - data_access.base_repository - ERROR - Error executing function sp_get_event_by_id: structure of query does not match function result type
DETAIL:  Возвращаемый тип character varying(255) не соответствует ожидаемому типу text в столбце 12.
CONTEXT:  SQL-оператор: "SELECT
        e.event_id,
        e.name,
        e.description,
        e.start_date,
        e.end_date,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                CASE
                    WHEN e.start_date = e.end_date THEN
                        TO_CHAR(e.start_date, 'DD.MM.YYYY')
                    ELSE
                        TO_CHAR(e.start_date, 'DD.MM.YYYY') || ' - ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
                END
            WHEN e.start_date IS NOT NULL AND e.end_date IS NULL THEN
                'с ' || TO_CHAR(e.start_date, 'DD.MM.YYYY')
            WHEN e.start_date IS NULL AND e.end_date IS NOT NULL THEN
                'до ' || TO_CHAR(e.end_date, 'DD.MM.YYYY')
            ELSE 'период неизвестен'
        END as period_text,
        CASE
            WHEN e.start_date IS NOT NULL AND e.end_date IS NOT NULL THEN
                (e.end_date - e.start_date)::integer
            ELSE NULL
        END as duration_days,
        e.location,
        e.event_type,
        e.parent_id,
        pe.name as parent_name,
        COALESCE(pe.name, e.name) as parent_path,  -- Упрощенный путь
        CASE WHEN e.parent_id IS NULL THEN 0 ELSE 1 END as level_in_hierarchy,  -- Упрощенный уровень
        (SELECT COUNT(*)::integer FROM public.events ce WHERE ce.parent_id = e.event_id) as children_count,
        (SELECT COUNT(*)::integer FROM public.events_persons ep WHERE ep.event_id = e.event_id) as persons_count,
        (SELECT COUNT(*)::integer FROM public.countries_events ce WHERE ce.event_id = e.event_id) as countries_count,
        (SELECT COUNT(*)::integer FROM public.documents_events de WHERE de.event_id = e.event_id) as documents_count,
        (SELECT COUNT(*)::integer FROM public.events_sources es WHERE es.event_id = e.event_id) as sources_count
    FROM public.events e
    LEFT JOIN public.events pe ON e.parent_id = pe.event_id
    WHERE e.event_id = p_event_id"
функция PL/pgSQL sp_get_event_by_id(integer), строка 3, оператор RETURN QUERY
2025-05-29 19:59:08,317 - core.database - ERROR - Error executing function sp_search_countries_fulltext with params ('CCCH', 0, 20): structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 9.
CONTEXT:  SQL-оператор: "SELECT 
        c.country_id,
        c.name,
        c.capital,
        c.foundation_date,
        c.dissolution_date,
        CASE 
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM c.foundation_date), ' - ', EXTRACT(YEAR FROM c.dissolution_date))
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NULL THEN
                CONCAT('с ', EXTRACT(YEAR FROM c.foundation_date))
            WHEN c.foundation_date IS NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT('до ', EXTRACT(YEAR FROM c.dissolution_date))
            ELSE 'период неизвестен'
        END as existence_period,
        CASE 
            WHEN c.dissolution_date IS NULL THEN 'существует'
            ELSE 'историческое'
        END as status,
        c.description,
        (
            CASE WHEN c.name ILIKE '%' || p_search_text || '%' THEN 4.0 ELSE 0.0 END +
            CASE WHEN c.capital ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN c.description ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.countries c
    WHERE 
        c.name ILIKE '%' || p_search_text || '%' OR 
        c.capital ILIKE '%' || p_search_text || '%' OR
        c.description ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, c.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_countries_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:59:08,318 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 9.
CONTEXT:  SQL-оператор: "SELECT 
        c.country_id,
        c.name,
        c.capital,
        c.foundation_date,
        c.dissolution_date,
        CASE 
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM c.foundation_date), ' - ', EXTRACT(YEAR FROM c.dissolution_date))
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NULL THEN
                CONCAT('с ', EXTRACT(YEAR FROM c.foundation_date))
            WHEN c.foundation_date IS NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT('до ', EXTRACT(YEAR FROM c.dissolution_date))
            ELSE 'период неизвестен'
        END as existence_period,
        CASE 
            WHEN c.dissolution_date IS NULL THEN 'существует'
            ELSE 'историческое'
        END as status,
        c.description,
        (
            CASE WHEN c.name ILIKE '%' || p_search_text || '%' THEN 4.0 ELSE 0.0 END +
            CASE WHEN c.capital ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN c.description ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.countries c
    WHERE 
        c.name ILIKE '%' || p_search_text || '%' OR 
        c.capital ILIKE '%' || p_search_text || '%' OR
        c.description ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, c.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_countries_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:59:08,318 - data_access.base_repository - ERROR - Error executing function sp_search_countries_fulltext: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 9.
CONTEXT:  SQL-оператор: "SELECT 
        c.country_id,
        c.name,
        c.capital,
        c.foundation_date,
        c.dissolution_date,
        CASE 
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM c.foundation_date), ' - ', EXTRACT(YEAR FROM c.dissolution_date))
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NULL THEN
                CONCAT('с ', EXTRACT(YEAR FROM c.foundation_date))
            WHEN c.foundation_date IS NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT('до ', EXTRACT(YEAR FROM c.dissolution_date))
            ELSE 'период неизвестен'
        END as existence_period,
        CASE 
            WHEN c.dissolution_date IS NULL THEN 'существует'
            ELSE 'историческое'
        END as status,
        c.description,
        (
            CASE WHEN c.name ILIKE '%' || p_search_text || '%' THEN 4.0 ELSE 0.0 END +
            CASE WHEN c.capital ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN c.description ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.countries c
    WHERE 
        c.name ILIKE '%' || p_search_text || '%' OR 
        c.capital ILIKE '%' || p_search_text || '%' OR
        c.description ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, c.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_countries_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:59:25,520 - core.database - ERROR - Error executing function sp_search_countries_fulltext with params ('СССР', 0, 20): structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 9.
CONTEXT:  SQL-оператор: "SELECT 
        c.country_id,
        c.name,
        c.capital,
        c.foundation_date,
        c.dissolution_date,
        CASE 
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM c.foundation_date), ' - ', EXTRACT(YEAR FROM c.dissolution_date))
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NULL THEN
                CONCAT('с ', EXTRACT(YEAR FROM c.foundation_date))
            WHEN c.foundation_date IS NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT('до ', EXTRACT(YEAR FROM c.dissolution_date))
            ELSE 'период неизвестен'
        END as existence_period,
        CASE 
            WHEN c.dissolution_date IS NULL THEN 'существует'
            ELSE 'историческое'
        END as status,
        c.description,
        (
            CASE WHEN c.name ILIKE '%' || p_search_text || '%' THEN 4.0 ELSE 0.0 END +
            CASE WHEN c.capital ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN c.description ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.countries c
    WHERE 
        c.name ILIKE '%' || p_search_text || '%' OR 
        c.capital ILIKE '%' || p_search_text || '%' OR
        c.description ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, c.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_countries_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:59:25,521 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 9.
CONTEXT:  SQL-оператор: "SELECT 
        c.country_id,
        c.name,
        c.capital,
        c.foundation_date,
        c.dissolution_date,
        CASE 
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM c.foundation_date), ' - ', EXTRACT(YEAR FROM c.dissolution_date))
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NULL THEN
                CONCAT('с ', EXTRACT(YEAR FROM c.foundation_date))
            WHEN c.foundation_date IS NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT('до ', EXTRACT(YEAR FROM c.dissolution_date))
            ELSE 'период неизвестен'
        END as existence_period,
        CASE 
            WHEN c.dissolution_date IS NULL THEN 'существует'
            ELSE 'историческое'
        END as status,
        c.description,
        (
            CASE WHEN c.name ILIKE '%' || p_search_text || '%' THEN 4.0 ELSE 0.0 END +
            CASE WHEN c.capital ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN c.description ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.countries c
    WHERE 
        c.name ILIKE '%' || p_search_text || '%' OR 
        c.capital ILIKE '%' || p_search_text || '%' OR
        c.description ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, c.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_countries_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:59:25,521 - data_access.base_repository - ERROR - Error executing function sp_search_countries_fulltext: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 9.
CONTEXT:  SQL-оператор: "SELECT 
        c.country_id,
        c.name,
        c.capital,
        c.foundation_date,
        c.dissolution_date,
        CASE 
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT(EXTRACT(YEAR FROM c.foundation_date), ' - ', EXTRACT(YEAR FROM c.dissolution_date))
            WHEN c.foundation_date IS NOT NULL AND c.dissolution_date IS NULL THEN
                CONCAT('с ', EXTRACT(YEAR FROM c.foundation_date))
            WHEN c.foundation_date IS NULL AND c.dissolution_date IS NOT NULL THEN
                CONCAT('до ', EXTRACT(YEAR FROM c.dissolution_date))
            ELSE 'период неизвестен'
        END as existence_period,
        CASE 
            WHEN c.dissolution_date IS NULL THEN 'существует'
            ELSE 'историческое'
        END as status,
        c.description,
        (
            CASE WHEN c.name ILIKE '%' || p_search_text || '%' THEN 4.0 ELSE 0.0 END +
            CASE WHEN c.capital ILIKE '%' || p_search_text || '%' THEN 2.0 ELSE 0.0 END +
            CASE WHEN c.description ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.countries c
    WHERE 
        c.name ILIKE '%' || p_search_text || '%' OR 
        c.capital ILIKE '%' || p_search_text || '%' OR
        c.description ILIKE '%' || p_search_text || '%'
    ORDER BY relevance_score DESC, c.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_countries_fulltext(text,integer,integer), строка 3, оператор RETURN QUERY
2025-05-29 19:59:36,706 - core.database - INFO - Database connection pool closed
2025-05-29 21:14:45,055 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 21:14:52,580 - __main__ - INFO - User logged in successfully: aboba3
2025-05-29 21:38:08,604 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 21:38:15,880 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 21:38:17,905 - matplotlib.font_manager - INFO - generated new fontManager
2025-05-29 21:38:31,289 - core.database - ERROR - Error executing function sp_get_pending_change_requests with params (0, 50, None): отношение "public.change_requests" не существует
LINE 4:     FROM public.change_requests cr
                 ^
QUERY:  SELECT cr.request_id, cr.user_id, u.username, cr.entity_type, cr.entity_id,
           cr.operation_type, cr.old_data, cr.new_data, cr.created_at,
           COUNT(*) OVER() as total_count
    FROM public.change_requests cr
    JOIN public.users u ON cr.user_id = u.user_id
    WHERE cr.status = 'PENDING'
      AND (p_entity_type IS NULL OR cr.entity_type = p_entity_type)
    ORDER BY cr.created_at ASC
    OFFSET p_offset
    LIMIT p_limit
CONTEXT:  функция PL/pgSQL sp_get_pending_change_requests(integer,integer,character varying), строка 3, оператор RETURN QUERY
2025-05-29 21:38:31,289 - core.database - ERROR - Database error: отношение "public.change_requests" не существует
LINE 4:     FROM public.change_requests cr
                 ^
QUERY:  SELECT cr.request_id, cr.user_id, u.username, cr.entity_type, cr.entity_id,
           cr.operation_type, cr.old_data, cr.new_data, cr.created_at,
           COUNT(*) OVER() as total_count
    FROM public.change_requests cr
    JOIN public.users u ON cr.user_id = u.user_id
    WHERE cr.status = 'PENDING'
      AND (p_entity_type IS NULL OR cr.entity_type = p_entity_type)
    ORDER BY cr.created_at ASC
    OFFSET p_offset
    LIMIT p_limit
CONTEXT:  функция PL/pgSQL sp_get_pending_change_requests(integer,integer,character varying), строка 3, оператор RETURN QUERY
2025-05-29 21:38:31,290 - data_access.base_repository - ERROR - Error executing function sp_get_pending_change_requests: отношение "public.change_requests" не существует
LINE 4:     FROM public.change_requests cr
                 ^
QUERY:  SELECT cr.request_id, cr.user_id, u.username, cr.entity_type, cr.entity_id,
           cr.operation_type, cr.old_data, cr.new_data, cr.created_at,
           COUNT(*) OVER() as total_count
    FROM public.change_requests cr
    JOIN public.users u ON cr.user_id = u.user_id
    WHERE cr.status = 'PENDING'
      AND (p_entity_type IS NULL OR cr.entity_type = p_entity_type)
    ORDER BY cr.created_at ASC
    OFFSET p_offset
    LIMIT p_limit
CONTEXT:  функция PL/pgSQL sp_get_pending_change_requests(integer,integer,character varying), строка 3, оператор RETURN QUERY
2025-05-29 21:38:53,128 - core.database - ERROR - Error executing function sp_get_pending_change_requests with params (0, 50, None): отношение "public.change_requests" не существует
LINE 4:     FROM public.change_requests cr
                 ^
QUERY:  SELECT cr.request_id, cr.user_id, u.username, cr.entity_type, cr.entity_id,
           cr.operation_type, cr.old_data, cr.new_data, cr.created_at,
           COUNT(*) OVER() as total_count
    FROM public.change_requests cr
    JOIN public.users u ON cr.user_id = u.user_id
    WHERE cr.status = 'PENDING'
      AND (p_entity_type IS NULL OR cr.entity_type = p_entity_type)
    ORDER BY cr.created_at ASC
    OFFSET p_offset
    LIMIT p_limit
CONTEXT:  функция PL/pgSQL sp_get_pending_change_requests(integer,integer,character varying), строка 3, оператор RETURN QUERY
2025-05-29 21:38:53,128 - core.database - ERROR - Database error: отношение "public.change_requests" не существует
LINE 4:     FROM public.change_requests cr
                 ^
QUERY:  SELECT cr.request_id, cr.user_id, u.username, cr.entity_type, cr.entity_id,
           cr.operation_type, cr.old_data, cr.new_data, cr.created_at,
           COUNT(*) OVER() as total_count
    FROM public.change_requests cr
    JOIN public.users u ON cr.user_id = u.user_id
    WHERE cr.status = 'PENDING'
      AND (p_entity_type IS NULL OR cr.entity_type = p_entity_type)
    ORDER BY cr.created_at ASC
    OFFSET p_offset
    LIMIT p_limit
CONTEXT:  функция PL/pgSQL sp_get_pending_change_requests(integer,integer,character varying), строка 3, оператор RETURN QUERY
2025-05-29 21:38:53,128 - data_access.base_repository - ERROR - Error executing function sp_get_pending_change_requests: отношение "public.change_requests" не существует
LINE 4:     FROM public.change_requests cr
                 ^
QUERY:  SELECT cr.request_id, cr.user_id, u.username, cr.entity_type, cr.entity_id,
           cr.operation_type, cr.old_data, cr.new_data, cr.created_at,
           COUNT(*) OVER() as total_count
    FROM public.change_requests cr
    JOIN public.users u ON cr.user_id = u.user_id
    WHERE cr.status = 'PENDING'
      AND (p_entity_type IS NULL OR cr.entity_type = p_entity_type)
    ORDER BY cr.created_at ASC
    OFFSET p_offset
    LIMIT p_limit
CONTEXT:  функция PL/pgSQL sp_get_pending_change_requests(integer,integer,character varying), строка 3, оператор RETURN QUERY
2025-05-29 21:39:29,387 - core.database - ERROR - Error executing function sp_get_pending_change_requests with params (0, 50, None): отношение "public.change_requests" не существует
LINE 4:     FROM public.change_requests cr
                 ^
QUERY:  SELECT cr.request_id, cr.user_id, u.username, cr.entity_type, cr.entity_id,
           cr.operation_type, cr.old_data, cr.new_data, cr.created_at,
           COUNT(*) OVER() as total_count
    FROM public.change_requests cr
    JOIN public.users u ON cr.user_id = u.user_id
    WHERE cr.status = 'PENDING'
      AND (p_entity_type IS NULL OR cr.entity_type = p_entity_type)
    ORDER BY cr.created_at ASC
    OFFSET p_offset
    LIMIT p_limit
CONTEXT:  функция PL/pgSQL sp_get_pending_change_requests(integer,integer,character varying), строка 3, оператор RETURN QUERY
2025-05-29 21:39:29,387 - core.database - ERROR - Database error: отношение "public.change_requests" не существует
LINE 4:     FROM public.change_requests cr
                 ^
QUERY:  SELECT cr.request_id, cr.user_id, u.username, cr.entity_type, cr.entity_id,
           cr.operation_type, cr.old_data, cr.new_data, cr.created_at,
           COUNT(*) OVER() as total_count
    FROM public.change_requests cr
    JOIN public.users u ON cr.user_id = u.user_id
    WHERE cr.status = 'PENDING'
      AND (p_entity_type IS NULL OR cr.entity_type = p_entity_type)
    ORDER BY cr.created_at ASC
    OFFSET p_offset
    LIMIT p_limit
CONTEXT:  функция PL/pgSQL sp_get_pending_change_requests(integer,integer,character varying), строка 3, оператор RETURN QUERY
2025-05-29 21:39:29,388 - data_access.base_repository - ERROR - Error executing function sp_get_pending_change_requests: отношение "public.change_requests" не существует
LINE 4:     FROM public.change_requests cr
                 ^
QUERY:  SELECT cr.request_id, cr.user_id, u.username, cr.entity_type, cr.entity_id,
           cr.operation_type, cr.old_data, cr.new_data, cr.created_at,
           COUNT(*) OVER() as total_count
    FROM public.change_requests cr
    JOIN public.users u ON cr.user_id = u.user_id
    WHERE cr.status = 'PENDING'
      AND (p_entity_type IS NULL OR cr.entity_type = p_entity_type)
    ORDER BY cr.created_at ASC
    OFFSET p_offset
    LIMIT p_limit
CONTEXT:  функция PL/pgSQL sp_get_pending_change_requests(integer,integer,character varying), строка 3, оператор RETURN QUERY
2025-05-29 22:23:43,976 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:23:52,379 - __main__ - INFO - User logged in successfully: aboba3
2025-05-29 22:26:36,574 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:26:49,683 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 22:27:54,787 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:28:04,836 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 22:31:01,101 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:31:09,516 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 22:31:22,642 - core.database - INFO - Database connection pool closed
2025-05-29 22:32:02,207 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:32:13,589 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 22:35:24,006 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:35:32,146 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 22:35:46,207 - core.database - INFO - Database connection pool closed
2025-05-29 22:35:49,946 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:35:59,611 - __main__ - INFO - User logged in successfully: aboba3
2025-05-29 22:36:32,714 - core.database - INFO - Database connection pool closed
2025-05-29 22:37:41,908 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:37:51,467 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 22:37:56,940 - core.database - INFO - Database connection pool closed
2025-05-29 22:37:59,312 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:38:19,755 - __main__ - INFO - User logged in successfully: aboba3
2025-05-29 22:39:14,195 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:39:21,849 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 22:41:45,558 - core.database - INFO - Database connection pool initialized successfully
2025-05-29 22:41:54,402 - __main__ - INFO - User logged in successfully: magcurie
2025-05-29 22:42:04,228 - core.database - ERROR - Error executing function sp_approve_change_request with params (1, 3, None): столбец "moderator_id" в таблице "change_requests" не существует
LINE 3:         moderator_id = p_moderator_id,
                ^
QUERY:  UPDATE public.change_requests
    SET status = 'APPROVED',
        moderator_id = p_moderator_id,
        moderator_comment = p_comment,
        reviewed_at = CURRENT_TIMESTAMP
    WHERE request_id = p_request_id
CONTEXT:  функция PL/pgSQL sp_approve_change_request(integer,integer,text), строка 16, оператор SQL-оператор
2025-05-29 22:42:04,228 - core.database - ERROR - Database error: столбец "moderator_id" в таблице "change_requests" не существует
LINE 3:         moderator_id = p_moderator_id,
                ^
QUERY:  UPDATE public.change_requests
    SET status = 'APPROVED',
        moderator_id = p_moderator_id,
        moderator_comment = p_comment,
        reviewed_at = CURRENT_TIMESTAMP
    WHERE request_id = p_request_id
CONTEXT:  функция PL/pgSQL sp_approve_change_request(integer,integer,text), строка 16, оператор SQL-оператор
2025-05-29 22:42:04,229 - data_access.base_repository - ERROR - Error executing function sp_approve_change_request: столбец "moderator_id" в таблице "change_requests" не существует
LINE 3:         moderator_id = p_moderator_id,
                ^
QUERY:  UPDATE public.change_requests
    SET status = 'APPROVED',
        moderator_id = p_moderator_id,
        moderator_comment = p_comment,
        reviewed_at = CURRENT_TIMESTAMP
    WHERE request_id = p_request_id
CONTEXT:  функция PL/pgSQL sp_approve_change_request(integer,integer,text), строка 16, оператор SQL-оператор
2025-05-29 22:43:01,044 - core.database - INFO - Database connection pool closed
2025-06-02 22:11:59,426 - core.database - INFO - Database connection pool initialized successfully
2025-06-02 22:12:09,131 - __main__ - INFO - User logged in successfully: magcurie
2025-06-02 22:13:32,321 - core.database - INFO - Database connection pool closed
2025-06-02 22:14:50,665 - core.database - INFO - Database connection pool initialized successfully
2025-06-02 22:15:02,200 - __main__ - INFO - User logged in successfully: magcurie
2025-06-02 22:29:17,360 - core.database - INFO - Database connection pool closed
2025-06-02 22:33:05,504 - core.database - INFO - Database connection pool initialized successfully
2025-06-02 22:33:15,290 - __main__ - INFO - User logged in successfully: magcurie
2025-06-02 22:34:27,140 - core.database - ERROR - Error executing function sp_search_documents_fulltext with params ('кон', False, 0, 20): structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 7.
CONTEXT:  SQL-оператор: "SELECT 
        d.document_id,
        d.name,
        CASE 
            WHEN LENGTH(d.content) > 200 THEN
                CONCAT(LEFT(d.content, 200), '...')
            ELSE d.content
        END as content_preview,
        LENGTH(d.content) as content_length,
        d.creating_date,
        CASE 
            WHEN d.creating_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM d.creating_date)::integer
            ELSE NULL
        END as age_years,
        (
            CASE WHEN d.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p_search_in_content AND d.content ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.documents d
    WHERE 
        d.name ILIKE '%' || p_search_text || '%' OR 
        (p_search_in_content AND d.content ILIKE '%' || p_search_text || '%')
    ORDER BY relevance_score DESC, d.creating_date DESC, d.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_documents_fulltext(text,boolean,integer,integer), строка 3, оператор RETURN QUERY
2025-06-02 22:34:27,141 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 7.
CONTEXT:  SQL-оператор: "SELECT 
        d.document_id,
        d.name,
        CASE 
            WHEN LENGTH(d.content) > 200 THEN
                CONCAT(LEFT(d.content, 200), '...')
            ELSE d.content
        END as content_preview,
        LENGTH(d.content) as content_length,
        d.creating_date,
        CASE 
            WHEN d.creating_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM d.creating_date)::integer
            ELSE NULL
        END as age_years,
        (
            CASE WHEN d.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p_search_in_content AND d.content ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.documents d
    WHERE 
        d.name ILIKE '%' || p_search_text || '%' OR 
        (p_search_in_content AND d.content ILIKE '%' || p_search_text || '%')
    ORDER BY relevance_score DESC, d.creating_date DESC, d.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_documents_fulltext(text,boolean,integer,integer), строка 3, оператор RETURN QUERY
2025-06-02 22:34:27,142 - data_access.base_repository - ERROR - Error executing function sp_search_documents_fulltext: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 7.
CONTEXT:  SQL-оператор: "SELECT 
        d.document_id,
        d.name,
        CASE 
            WHEN LENGTH(d.content) > 200 THEN
                CONCAT(LEFT(d.content, 200), '...')
            ELSE d.content
        END as content_preview,
        LENGTH(d.content) as content_length,
        d.creating_date,
        CASE 
            WHEN d.creating_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM d.creating_date)::integer
            ELSE NULL
        END as age_years,
        (
            CASE WHEN d.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p_search_in_content AND d.content ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.documents d
    WHERE 
        d.name ILIKE '%' || p_search_text || '%' OR 
        (p_search_in_content AND d.content ILIKE '%' || p_search_text || '%')
    ORDER BY relevance_score DESC, d.creating_date DESC, d.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_documents_fulltext(text,boolean,integer,integer), строка 3, оператор RETURN QUERY
2025-06-02 22:34:39,491 - core.database - ERROR - Error executing function sp_search_documents_fulltext with params ('Конст', False, 0, 20): structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 7.
CONTEXT:  SQL-оператор: "SELECT 
        d.document_id,
        d.name,
        CASE 
            WHEN LENGTH(d.content) > 200 THEN
                CONCAT(LEFT(d.content, 200), '...')
            ELSE d.content
        END as content_preview,
        LENGTH(d.content) as content_length,
        d.creating_date,
        CASE 
            WHEN d.creating_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM d.creating_date)::integer
            ELSE NULL
        END as age_years,
        (
            CASE WHEN d.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p_search_in_content AND d.content ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.documents d
    WHERE 
        d.name ILIKE '%' || p_search_text || '%' OR 
        (p_search_in_content AND d.content ILIKE '%' || p_search_text || '%')
    ORDER BY relevance_score DESC, d.creating_date DESC, d.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_documents_fulltext(text,boolean,integer,integer), строка 3, оператор RETURN QUERY
2025-06-02 22:34:39,492 - core.database - ERROR - Database error: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 7.
CONTEXT:  SQL-оператор: "SELECT 
        d.document_id,
        d.name,
        CASE 
            WHEN LENGTH(d.content) > 200 THEN
                CONCAT(LEFT(d.content, 200), '...')
            ELSE d.content
        END as content_preview,
        LENGTH(d.content) as content_length,
        d.creating_date,
        CASE 
            WHEN d.creating_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM d.creating_date)::integer
            ELSE NULL
        END as age_years,
        (
            CASE WHEN d.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p_search_in_content AND d.content ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.documents d
    WHERE 
        d.name ILIKE '%' || p_search_text || '%' OR 
        (p_search_in_content AND d.content ILIKE '%' || p_search_text || '%')
    ORDER BY relevance_score DESC, d.creating_date DESC, d.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_documents_fulltext(text,boolean,integer,integer), строка 3, оператор RETURN QUERY
2025-06-02 22:34:39,493 - data_access.base_repository - ERROR - Error executing function sp_search_documents_fulltext: structure of query does not match function result type
DETAIL:  Возвращаемый тип numeric не соответствует ожидаемому типу real в столбце 7.
CONTEXT:  SQL-оператор: "SELECT 
        d.document_id,
        d.name,
        CASE 
            WHEN LENGTH(d.content) > 200 THEN
                CONCAT(LEFT(d.content, 200), '...')
            ELSE d.content
        END as content_preview,
        LENGTH(d.content) as content_length,
        d.creating_date,
        CASE 
            WHEN d.creating_date IS NOT NULL THEN
                EXTRACT(YEAR FROM CURRENT_DATE)::integer - EXTRACT(YEAR FROM d.creating_date)::integer
            ELSE NULL
        END as age_years,
        (
            CASE WHEN d.name ILIKE '%' || p_search_text || '%' THEN 3.0 ELSE 0.0 END +
            CASE WHEN p_search_in_content AND d.content ILIKE '%' || p_search_text || '%' THEN 1.0 ELSE 0.0 END
        ) as relevance_score,
        COUNT(*) OVER() as total_count
    FROM public.documents d
    WHERE 
        d.name ILIKE '%' || p_search_text || '%' OR 
        (p_search_in_content AND d.content ILIKE '%' || p_search_text || '%')
    ORDER BY relevance_score DESC, d.creating_date DESC, d.name
    OFFSET p_offset
    LIMIT p_limit"
функция PL/pgSQL sp_search_documents_fulltext(text,boolean,integer,integer), строка 3, оператор RETURN QUERY
2025-06-02 22:44:51,938 - core.database - INFO - Database connection pool closed
2025-06-02 23:15:25,703 - core.database - INFO - Database connection pool initialized successfully
2025-06-02 23:15:35,482 - __main__ - INFO - User logged in successfully: magcurie
2025-06-02 23:16:00,262 - core.database - INFO - Database connection pool closed
2025-06-02 23:16:04,088 - core.database - INFO - Database connection pool initialized successfully
2025-06-02 23:16:10,821 - __main__ - INFO - User logged in successfully: aboba3
2025-06-02 23:16:53,613 - core.database - INFO - Database connection pool initialized successfully
2025-06-02 23:17:01,893 - __main__ - INFO - User logged in successfully: magcurie
2025-06-02 23:17:26,842 - core.database - INFO - Database connection pool closed
